{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DAB-Radio v2.0 \u00dcbersicht Das DAB-Radio ist eine portable Lautsprecherbox mit einem integrierten Mikrocontroller. Welches nebst den Standart-IO's auch \u00fcber Bluetooth Audio und Wifi konnektivt\u00e4t verf\u00fcgt. Die dazugeh\u00f6rige Software wird per Arduino Entwicklungsumgebung realisiert. F\u00fcr die Anzeige des Men\u00fcs und die Bedienung, verf\u00fcgt das Ger\u00e4t \u00fcber ein TFT Touch-Display mit einer Aufl\u00f6sung von 320x240 Pixel. Folgende Bedienelemente sind vorhanden: Lautst\u00e4rke(Encoder 2) Umschaltung Signalquelle (GUI) Mute (Stummschaltung per Encoder-Button) Eingabetasten (Men\u00fcbedienung) Addressierbare Beleuchtung f\u00fcr Statusanzeigen(RGB). Dieses Projekt wurde mihilfe von MEM-Lernenden im Regionalen Ausbildungszentrum in Au realisiert. Die Software Entwicklung Als erstes wurde eine Testsoftware entwickelt um alle im Prototyp verwendeten Komponenten vor der ersten Inbetriebnahme ausgiebig testen zu k\u00f6nnen. Im n\u00e4chsten Schritt erfolgt eine minimales Men\u00fc mit allen Grundfunktionen des Radios.","title":"Code Beschreibung"},{"location":"#dab-radio-v20","text":"","title":"DAB-Radio v2.0"},{"location":"#ubersicht","text":"Das DAB-Radio ist eine portable Lautsprecherbox mit einem integrierten Mikrocontroller. Welches nebst den Standart-IO's auch \u00fcber Bluetooth Audio und Wifi konnektivt\u00e4t verf\u00fcgt. Die dazugeh\u00f6rige Software wird per Arduino Entwicklungsumgebung realisiert. F\u00fcr die Anzeige des Men\u00fcs und die Bedienung, verf\u00fcgt das Ger\u00e4t \u00fcber ein TFT Touch-Display mit einer Aufl\u00f6sung von 320x240 Pixel.","title":"\u00dcbersicht"},{"location":"#folgende-bedienelemente-sind-vorhanden","text":"Lautst\u00e4rke(Encoder 2) Umschaltung Signalquelle (GUI) Mute (Stummschaltung per Encoder-Button) Eingabetasten (Men\u00fcbedienung) Addressierbare Beleuchtung f\u00fcr Statusanzeigen(RGB). Dieses Projekt wurde mihilfe von MEM-Lernenden im Regionalen Ausbildungszentrum in Au realisiert.","title":"Folgende Bedienelemente sind vorhanden:"},{"location":"#die-software-entwicklung","text":"Als erstes wurde eine Testsoftware entwickelt um alle im Prototyp verwendeten Komponenten vor der ersten Inbetriebnahme ausgiebig testen zu k\u00f6nnen. Im n\u00e4chsten Schritt erfolgt eine minimales Men\u00fc mit allen Grundfunktionen des Radios.","title":"Die Software Entwicklung"},{"location":"Anpassungen%20des%20Codes/","text":"Anpassungen des Codes TO DO","title":"Anpassungen des Codes"},{"location":"Anpassungen%20des%20Codes/#anpassungen-des-codes","text":"TO DO","title":"Anpassungen des Codes"},{"location":"Aufbau/","text":"Aufbau TO DO","title":"Aufbau"},{"location":"Aufbau/#aufbau","text":"TO DO","title":"Aufbau"},{"location":"Datenbl%C3%A4tter/","text":"Datenbl\u00e4tter - ESP32 - ESP32-Wrover-IE - Bluetooth Modul - BM83 - Port Expander - MCP23017 - Sound Prozessor - BD37544FS - LiPo Charger - bq25895 - Fuel Gauge - bq27441-G1 - TFT 2.8\" Display - ILI9341 - Touch Controller - FT6206 (in Display integriert)","title":"Datenbl\u00e4tter"},{"location":"Datenbl%C3%A4tter/#datenblatter","text":"- ESP32 - ESP32-Wrover-IE - Bluetooth Modul - BM83 - Port Expander - MCP23017 - Sound Prozessor - BD37544FS - LiPo Charger - bq25895 - Fuel Gauge - bq27441-G1 - TFT 2.8\" Display - ILI9341 - Touch Controller - FT6206 (in Display integriert)","title":"Datenbl\u00e4tter"},{"location":"Hard-%20und%20Software%20Knfiguration/","text":"Hard- und Software Konfiguration Hardware Men\u00fcbedienung \u00fcber Touch-Funktion des Displays oder per Eingabe von Buttons und Encoder Statusanzeigen \u00fcber addresierbare RGB-Leds Steuerung der weiteren Module des DAB-Radios Bluetooth Modul - BM83 (UART) Sound Prozessor - BD37544FS (I2C) LiPo Charger - bq25895 (I2C) Fuel Gauge - bq27441-G1 (I2C) inkl. erweiterbare I/O's per Port Expander - MCP23017 (I2C) Software Basis Code in C++ (Arduino) Hardware API per (Arduino ESP32 Core) Integriertes Echtzeitbetriebssystem im Core (FreeRTOS) GUI per (GuiSlice) Arduino Library","title":"Hard- und Software Konfiguration"},{"location":"Hard-%20und%20Software%20Knfiguration/#hard-und-software-konfiguration","text":"","title":"Hard- und Software Konfiguration"},{"location":"Hard-%20und%20Software%20Knfiguration/#hardware","text":"Men\u00fcbedienung \u00fcber Touch-Funktion des Displays oder per Eingabe von Buttons und Encoder Statusanzeigen \u00fcber addresierbare RGB-Leds Steuerung der weiteren Module des DAB-Radios Bluetooth Modul - BM83 (UART) Sound Prozessor - BD37544FS (I2C) LiPo Charger - bq25895 (I2C) Fuel Gauge - bq27441-G1 (I2C) inkl. erweiterbare I/O's per Port Expander - MCP23017 (I2C)","title":"Hardware"},{"location":"Hard-%20und%20Software%20Knfiguration/#software","text":"Basis Code in C++ (Arduino) Hardware API per (Arduino ESP32 Core) Integriertes Echtzeitbetriebssystem im Core (FreeRTOS) GUI per (GuiSlice) Arduino Library","title":"Software"},{"location":"Installation%20der%20Entwicklungsumgebung/","text":"Installation der Entwicklungsumgebung Die Software kann entweder in der Arduino IDE oder in Visual Studio Code bearbeitet und kompiliert werden. Arduino IDE Voraussetzungen - Arduino IDE Software ab Version 1.8.X - Arduino ESP32 Core Damit sich der ESP32-Mikrocontroller mit der Arduino Umgebung versteht, wird hierzu der daf\u00fcr vom Hersteller entwickelte Core f\u00fcr die Arduino Umgebung ben\u00f6tigt. Installation und Konfiguration des Arduino ESP32 Core Arduino IDE starten und im Men\u00fctab \"File\" -> \"Preferences\" \u00f6ffnen. Bei \"Additional Boards Manager URLs\" den Link zum Core Release einf\u00fcgen -> https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json Anschliessend auf \"OK\" klicken und das Men\u00fc verlassen. Im Men\u00fctab \"Tools/Board:....\" dann \"Boards Manager\" Anschliessend \u00f6ffnet sich der \"Boards Manager\". Im Suchfenster \"ESP32\" suchen und installieren. Unter \"Tools/Board:...\" auf \"ESP32 Arduino\" gehen und \"ESP32 Dev Module\" ausw\u00e4hlen. Nun ist das Board mit den dazugeh\u00f6rigen Einstellungen ausgew\u00e4hlt und f\u00fcr Kompilierung und Upload bereit. Kompilieren und Flashen in der Arduino IDE Visual Studio Code mit Arduino (Extension) Voraussetzungen - Visual Studio Code Software -Marketplace Link VSC Arduino Extension Um die Entwicklung per Arduino Umgebung zu erm\u00f6glichen wird eine zus\u00e4tzliche Extension ben\u00f6tigt. Diese kann direkt in der Software-Umgebung oder per Marketplace Link installiert werden. Wichtig Arduino IDE inkl. ESP32 Arduino Core muss als erstes installiert werden um das Kompilieren und Uploaden von Arduino Code mit der Extension in Visual Studio Code zu erm\u00f6glichen. Kompilieren und Flashen in Visual Studio Code","title":"Installation der Entwicklungsumgebung"},{"location":"Installation%20der%20Entwicklungsumgebung/#installation-der-entwicklungsumgebung","text":"Die Software kann entweder in der Arduino IDE oder in Visual Studio Code bearbeitet und kompiliert werden.","title":"Installation der Entwicklungsumgebung"},{"location":"Installation%20der%20Entwicklungsumgebung/#arduino-ide","text":"","title":"Arduino IDE"},{"location":"Installation%20der%20Entwicklungsumgebung/#voraussetzungen","text":"- Arduino IDE Software ab Version 1.8.X - Arduino ESP32 Core Damit sich der ESP32-Mikrocontroller mit der Arduino Umgebung versteht, wird hierzu der daf\u00fcr vom Hersteller entwickelte Core f\u00fcr die Arduino Umgebung ben\u00f6tigt.","title":"Voraussetzungen"},{"location":"Installation%20der%20Entwicklungsumgebung/#installation-und-konfiguration-des-arduino-esp32-core","text":"Arduino IDE starten und im Men\u00fctab \"File\" -> \"Preferences\" \u00f6ffnen. Bei \"Additional Boards Manager URLs\" den Link zum Core Release einf\u00fcgen -> https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json Anschliessend auf \"OK\" klicken und das Men\u00fc verlassen. Im Men\u00fctab \"Tools/Board:....\" dann \"Boards Manager\" Anschliessend \u00f6ffnet sich der \"Boards Manager\". Im Suchfenster \"ESP32\" suchen und installieren. Unter \"Tools/Board:...\" auf \"ESP32 Arduino\" gehen und \"ESP32 Dev Module\" ausw\u00e4hlen. Nun ist das Board mit den dazugeh\u00f6rigen Einstellungen ausgew\u00e4hlt und f\u00fcr Kompilierung und Upload bereit.","title":"Installation und Konfiguration des Arduino ESP32 Core"},{"location":"Installation%20der%20Entwicklungsumgebung/#kompilieren-und-flashen-in-der-arduino-ide","text":"","title":"Kompilieren und Flashen in der Arduino IDE"},{"location":"Installation%20der%20Entwicklungsumgebung/#visual-studio-code-mit-arduino-extension","text":"","title":"Visual Studio Code mit Arduino (Extension)"},{"location":"Installation%20der%20Entwicklungsumgebung/#voraussetzungen_1","text":"- Visual Studio Code Software -Marketplace Link VSC Arduino Extension Um die Entwicklung per Arduino Umgebung zu erm\u00f6glichen wird eine zus\u00e4tzliche Extension ben\u00f6tigt. Diese kann direkt in der Software-Umgebung oder per Marketplace Link installiert werden. Wichtig Arduino IDE inkl. ESP32 Arduino Core muss als erstes installiert werden um das Kompilieren und Uploaden von Arduino Code mit der Extension in Visual Studio Code zu erm\u00f6glichen.","title":"Voraussetzungen"},{"location":"Installation%20der%20Entwicklungsumgebung/#kompilieren-und-flashen-in-visual-studio-code","text":"","title":"Kompilieren und Flashen in Visual Studio Code"},{"location":"Libraries/","text":"\u00dcbersicht Libraries werden \u00fcber Github bereitgestellt.","title":"\u00dcbersicht"},{"location":"Libraries/#ubersicht","text":"Libraries werden \u00fcber Github bereitgestellt.","title":"\u00dcbersicht"},{"location":"Quellen/","text":"Quellen Hier befinden sich Links und weitere Angaben der verwendeten Quellen f\u00fcr die Entwicklung der ersten Testsoftware. Software Arduino ESP32 Core - Arduino ESP32 Core LVGL - LVGL Github - LVGL Docs (7.11) Hardware ESP Ressourcen - ESP32-Allgemein - ESP32-PWM","title":"Quellen"},{"location":"Quellen/#quellen","text":"Hier befinden sich Links und weitere Angaben der verwendeten Quellen f\u00fcr die Entwicklung der ersten Testsoftware.","title":"Quellen"},{"location":"Quellen/#software","text":"","title":"Software"},{"location":"Quellen/#arduino-esp32-core","text":"- Arduino ESP32 Core","title":"Arduino ESP32 Core"},{"location":"Quellen/#lvgl","text":"- LVGL Github - LVGL Docs (7.11)","title":"LVGL"},{"location":"Quellen/#hardware","text":"","title":"Hardware"},{"location":"Quellen/#esp-ressourcen","text":"- ESP32-Allgemein - ESP32-PWM","title":"ESP Ressourcen"},{"location":"Testsoftware/","text":"Code Testsoftware v 1.0 - Github /** * @file DAB_2_V0.1.ino * * @mainpage DAB Radio V2.0 * * @section description \u00dcbersicht * An example sketch demonstrating how to use Doxygen style comments for * generating source code documentation with Doxygen. * * @section circuit Produkt * - 1 * - 2 * * @section libraries Libraries * - 2 * - 1 * * @section notes Notizen * - Comments are Doxygen compatible. * * @section todo TODO * - Don't use Doxygen style formatting inside the body of a function. * * @section author Author * - Created by Egzon Isaku on 16/06/2021. * - Modified by * * Copyright (c) RAU Regionales Ausbildungszentrum AU. All rights reserved. */ // Libraries #include <lvgl.h> // Light and versatile Embedded Graphics Library (LVGL) #include <TFT_eSPI.h> // General TFT library (TFT_eSPI) #include \"touch.h\" // Communication header for the touch controller - between \"FT6206\" and LVGL #include <Wire.h> // Arduino I2C library #include <PCA9634.h> // Led driver library (PCA9634) #include <MCP23017.h> // Port expander library (MPC23017) #include \"BM83.h\" // Bluetooth Module library (BM83/BM64) #include <SoftwareSerial.h> // SoftwareSerial Library for ESP32 #include <BD37544FS.h> // Sound processor library (BD37544FS) #include \"ESPRotary.h\" // Encoder Library f\u00fcr ESP32 #include \"soc/timer_group_struct.h\" // Watchdog timer #include \"soc/timer_group_reg.h\" // Watchdog timer // Defines #define BUFFER_MULTIPLIER 35 #define RX_PIN 4 #define TX_PIN 0 #define TX_IND 5 #define DAC1 26 #define ENC1_ROTARY_PIN_A 34 #define ENC1_ROTARY_PIN_B 35 #define ENC2_ROTARY_PIN_A 39 #define ENC2_ROTARY_PIN_B 36 #define CLICKS_PER_STEP 2 // this number depends on your rotary encoder #define MIN_POS 0 #define MAX_POS 87 #define START_POS 0 #define INCREMENT 1 // this number is the counter increment on each step const int mfbPin = 23; ESPRotary r; ESPRotary u; // Sound processor instance (BD37544FS) BD37544FS bd; // Bluetooth module instance (BM83) SoftwareSerial swSerial(RX_PIN, TX_PIN); BM83 bm83(swSerial, TX_IND); // Led driver instance (PCA9634) PCA9634 ledDriver(0x15, 4); // MPC 1 + 2 instance (MCP23017) MCP23017 mcp1 = MCP23017(0x20); MCP23017 mcp2 = MCP23017(0x24); // LVGL task handles TaskHandle_t Task1; TaskHandle_t Task2; static lv_group_t *g; //An object group static lv_indev_t *encoder_indev; //Encoder 1 input device // Global LVGL object variables lv_obj_t *tabview; lv_obj_t *tab1; lv_obj_t *tab2; lv_obj_t *tab3; lv_obj_t *tab4; lv_obj_t *gauge1; lv_obj_t *led1; lv_obj_t *btn; lv_obj_t *btn1; lv_obj_t *btn2; lv_obj_t *btn3; lv_obj_t *sw1; lv_obj_t *sw2; lv_obj_t *sw3; lv_obj_t *cont; lv_obj_t *cont2; lv_obj_t *cont3; lv_obj_t *bar1; lv_obj_t *lmeter; lv_obj_t *lmeter2; lv_obj_t *label; lv_obj_t *spinbox; lv_obj_t *slider_label; lv_obj_t *slider_label2; lv_obj_t *slider_label3; lv_obj_t *slider_label4; lv_obj_t *slider_label5; // Global variables uint8_t conf; int i; int vol; int encoderLastValue = 0; TFT_eSPI tft = TFT_eSPI(); /* TFT instance */ static lv_disp_buf_t disp_buf; static lv_color_t buf_1[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; static lv_color_t buf_2[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif /* Display flushing */ void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) { uint32_t w = (area->x2 - area->x1 + 1); uint32_t h = (area->y2 - area->y1 + 1); tft.startWrite(); tft.setAddrWindow(area->x1, area->y1, w, h); tft.pushColors(&color_p->full, w * h, true); tft.endWrite(); lv_disp_flush_ready(disp); } // The standard Arduino setup function used for setup and configuration void setup() { // I2C init @ 100 kHz Wire.begin(); Wire.setClock(100000); // Serial debugging @ 115200 baud Serial.begin(115200); // Software serial for BM83/BM64 Uart communication @ 9600 baud swSerial.begin(9600); // Input read task creation xTaskCreatePinnedToCore( read_inputs, /* Task function. */ \"read_inputs\", /* String with name of task. */ 10000, /* Stack size in bytes. */ NULL, /* Parameter passed as input of the task */ 1, /* Priority of the task. */ &Task1, /* Task handle. */ 0); /* Core 0 or 1 (Core 1 is used for the arduino loop function for now)*/ // Encoder read task creation //xTaskCreatePinnedToCore(encoder_loop, \"encoder_loop\", 10000, NULL, 2, &Task2, 0); // Sets the MFB pin (GPIO23) as output (BM83) pinMode(mfbPin, OUTPUT); // Encoder 1+2 init // Led driver init ledDriver.begin(); // all on (inverted) ledDriver.allOff(); // Charger IC setup---------------------------------------------------------------- Wire.beginTransmission(0x6A); Wire.write(0x14); Wire.write(0xB9); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x02); Wire.write(0x30); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x03); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x04); Wire.write(0x40); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x05); Wire.write(0x66); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x06); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x07); Wire.write(0x89); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x09); Wire.write(0x04); Wire.endTransmission(); // -------------------------------------------------------------------- //MCP 1 init mcp1.init(); mcp1.portMode(MCP23017Port::A, 0b11111111); // Set all as inputs (MCP1) delay(5); //MCP 2 init mcp2.init(); mcp2.portMode(MCP23017Port::A, 0); // Set all as outputs (MCP2) delay(5); // Standby sequence mcp2.digitalWrite(1, 0); // 7.5V disable delay(10); mcp2.digitalWrite(0, 0); // +-5V disable delay(10); mcp2.digitalWrite(2, 0); // PVCC disable delay(10); mcp2.digitalWrite(3, 0); // Power Amp shutdown activation delay(10); mcp2.digitalWrite(4, 1); // Power Amp mute activation // Power up sequence delay(20); mcp2.digitalWrite(1, 1); Serial.println(\"7.5V enabled!\"); // 7.5V enable delay(10); mcp2.digitalWrite(0, 1); Serial.println(\"+-5V enabled!\"); // +-5V enable delay(10); dacWrite(DAC1, 255); delay(10); mcp2.digitalWrite(2, 1); Serial.println(\"PVCC enabled!\"); // PVCC enable delay(10); mcp2.digitalWrite(3, 1); Serial.println(\"Power Amp Shutdown deactivated!\"); // Power amp shutdown deactivation delay(10); mcp2.digitalWrite(4, 0); Serial.println(\"Power Amp Mute deactivated!\"); // Power amp mute deactivation delay(10); // LVGL init lv_init(); #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif // TFT init tft.begin(); tft.setRotation(3); // Touch device init if (!touch.begin(150)) { Serial.println(\"Couldn't start FT6206 touchscreen controller\"); while (1) ; } else { Serial.println(\"FT6206 touchscreen controller connected!\"); } lv_disp_buf_init(&disp_buf, buf_1, buf_2, LV_HOR_RES_MAX * 10); // Display init lv_disp_drv_t disp_drv; lv_disp_drv_init(&disp_drv); disp_drv.hor_res = tft.width(); disp_drv.ver_res = tft.height(); disp_drv.flush_cb = my_disp_flush; disp_drv.buffer = &disp_buf; lv_disp_drv_register(&disp_drv); // Display input driver init lv_indev_drv_t indev_drv; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_POINTER; indev_drv.read_cb = my_touchpad_read; lv_indev_drv_register(&indev_drv); lv_indev_drv_t enc_indev; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_ENCODER; indev_drv.read_cb = encoder_read; encoder_indev = lv_indev_drv_register(&indev_drv); static lv_style_t style1; lv_style_init(&style1); lv_style_set_border_color(&style1, LV_STATE_FOCUSED, LV_COLOR_RED); //Create Group for encoder 1 g = lv_group_create(); lv_indev_set_group(encoder_indev, g); static lv_color_t needle_colors[3]; needle_colors[0] = LV_COLOR_BLUE; needle_colors[1] = LV_COLOR_ORANGE; needle_colors[2] = LV_COLOR_PURPLE; tabview = lv_tabview_create(lv_scr_act(), NULL); lv_tabview_set_btns_pos(tabview, LV_TABVIEW_TAB_POS_BOTTOM); //lv_tabview_set_anim_time(tabview, 100); /*Add 4 tabs (the tabs are page (lv_page) and can be scrolled*/ tab1 = lv_tabview_add_tab(tabview, \"Setups\"); tab2 = lv_tabview_add_tab(tabview, \"Values\"); tab3 = lv_tabview_add_tab(tabview, \"Enables\"); tab4 = lv_tabview_add_tab(tabview, \"Parameters\"); lmeter = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter, 100, 100); lv_obj_align(lmeter, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); lmeter2 = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter2, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter2, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter2, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter2, 100, 100); lv_obj_align(lmeter2, NULL, LV_ALIGN_IN_TOP_RIGHT, 0, 0); cont = lv_cont_create(tab3, NULL); lv_obj_set_auto_realign(cont, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont, LV_FIT_TIGHT); lv_cont_set_layout(cont, LV_LAYOUT_GRID); sw1 = lv_switch_create(cont, NULL); lv_obj_align(sw1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(sw1, NULL); lv_label_set_text(label, \"7.5V\"); lv_obj_set_event_cb(sw1, event_sw1); sw2 = lv_switch_create(cont, NULL); lv_obj_align(sw2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(sw2, NULL); lv_label_set_text(label, \"+-5V\"); lv_obj_set_event_cb(sw2, event_sw1); sw3 = lv_switch_create(cont, NULL); lv_obj_align(sw3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(sw3, NULL); lv_label_set_text(label, \"PVCC\"); lv_obj_set_event_cb(sw3, event_sw1); cont2 = lv_cont_create(tab1, NULL); lv_obj_set_auto_realign(cont2, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont2, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont2, LV_FIT_TIGHT); lv_cont_set_layout(cont2, LV_LAYOUT_GRID); btn1 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn1, event_bm83setup); lv_obj_align(btn1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(btn1, NULL); lv_label_set_text(label, \"BM83 Setup\"); lv_obj_add_style(btn1, LV_BTN_PART_MAIN, &style1); btn2 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn2, event_bm83pair); lv_obj_align(btn2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(btn2, NULL); lv_label_set_text(label, \"BM83 Pairing\"); lv_obj_add_style(btn2, LV_BTN_PART_MAIN, &style1); btn3 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn3, event_soundsetup); lv_obj_align(btn3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(btn3, NULL); lv_label_set_text(label, \"Sound Proc. Setup\"); lv_obj_add_style(btn3, LV_BTN_PART_MAIN, &style1); /* Create a slider in the center of the display */ lv_obj_t *slider = lv_slider_create(tab4, NULL); lv_obj_set_width(slider, LV_DPI * 1); lv_obj_align(slider, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 25); lv_obj_set_event_cb(slider, slider_event_cb_ingain); lv_slider_set_range(slider, 5, 20); /* Create a label below the slider */ slider_label = lv_label_create(tab4, NULL); lv_label_set_text(slider_label, \"0\"); lv_obj_set_auto_realign(slider_label, true); lv_obj_align(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 5, 10); /* Create an informative label */ lv_obj_t *info = lv_label_create(tab4, NULL); lv_label_set_text(info, \"Input Gain (0-20dB)\"); lv_obj_align(info, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 5); //______________________________________________________________ lv_obj_t *slider2 = lv_slider_create(tab4, NULL); lv_obj_set_width(slider2, LV_DPI * 1); lv_obj_align(slider2, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 60); lv_obj_set_event_cb(slider2, slider_event_cb_fade1); lv_slider_set_range(slider2, 0, 87); /* Create a label below the slider */ slider_label2 = lv_label_create(tab4, NULL); lv_label_set_text(slider_label2, \"0\"); lv_obj_set_auto_realign(slider_label2, true); lv_obj_align(slider_label2, slider2, LV_ALIGN_OUT_BOTTOM_MID, 5, 20); /* Create an informative label */ lv_obj_t *info2 = lv_label_create(tab4, NULL); lv_label_set_text(info2, \"Fader 1 (0-(-87dB))\"); lv_obj_align(info2, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 25); lv_group_add_obj(g, tabview); lv_group_add_obj(g, sw1); lv_group_add_obj(g, sw2); lv_group_add_obj(g, sw3); lv_group_add_obj(g, btn1); lv_group_add_obj(g, btn2); lv_group_add_obj(g, btn3); lv_group_set_wrap(g, true); lv_group_set_editing(g, true); r.begin(ENC1_ROTARY_PIN_A, ENC1_ROTARY_PIN_B, CLICKS_PER_STEP); r.setChangedHandler(rotate_r); r.setLeftRotationHandler(showDirection_r); r.setRightRotationHandler(showDirection_r); u.begin(ENC2_ROTARY_PIN_A, ENC2_ROTARY_PIN_B, CLICKS_PER_STEP, MIN_POS, MAX_POS, START_POS, INCREMENT); u.setChangedHandler(rotate_u); u.setLeftRotationHandler(showDirection_u); u.setRightRotationHandler(showDirection_u); } void loop() { // Watchdog timer manip TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; TIMERG0.wdt_feed = 1; TIMERG0.wdt_wprotect = 0; conf = mcp1.readRegister(MCP23017Register::GPIO_A); // MCP1 register read for inputs r.loop(); u.loop(); // LVGL task handler lv_task_handler(); delay(3); } void read_inputs(void *parameter) { for (;;) { bm83.run(); for (i = 7; i >= 0; i--) { if (bitRead(conf, i) == 1) { switch (i) { case 7: break; case 6: break; case 5: break; case 4: lv_tabview_set_tab_act(tabview, 3, LV_ANIM_OFF); break; case 3: lv_tabview_set_tab_act(tabview, 2, LV_ANIM_OFF); break; case 2: lv_tabview_set_tab_act(tabview, 1, LV_ANIM_OFF); break; case 1: lv_tabview_set_tab_act(tabview, 0, LV_ANIM_OFF); break; case 0: break; } } } } vTaskDelay(5); } static void event_bm83setup(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { printf(\"Clicked\\n\"); digitalWrite(mfbPin, HIGH); // sets the MFB Pin 23 \"High\" to power on BM83 over BAT_IN delay(500); bm83.run(); bm83.powerOn(); // Sends \"power on\" command over UART to BM83 digitalWrite(mfbPin, LOW); // sets the MFB Pin 23 \"LOW\" (no longer needed after power on process) } } static void event_bm83pair(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bm83.mmiAction(BM83_MMI_STANDBY_ENTERING_PAIRING); } } static void event_soundsetup(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bd.setSelect(1); // int 0...7 === A B C D E F INPUT_SHORT INPUT_MUTE bd.setIn_gain(0); // int 0...7 === 0...20 dB bd.setVol_1(0); // int 0...87 === 0...-87 dB bd.setFad_1(0); // int 0...87 === 0...-87 dB bd.setFad_2(0); // int 0...87 === 0...-87 dB bd.setBass(0); // int -7...0...+7 === -14...+14 dB bd.setMidd(0); // int -7...0...+7 === -14...+14 dB bd.setTreb(0); // int -7...0...+7 === -14...+14 dB } } static void event_sw1(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { printf(\"State: %s\\n\", lv_switch_get_state(obj) ? \"On\" : \"Off\"); if (lv_switch_get_state(sw1) == 1) { mcp2.digitalWrite(1, 1); } else { mcp2.digitalWrite(1, 0); } if (lv_switch_get_state(sw2) == 1) { mcp2.digitalWrite(0, 1); } else { mcp2.digitalWrite(0, 0); } if (lv_switch_get_state(sw3) == 1) { mcp2.digitalWrite(2, 1); } else { mcp2.digitalWrite(2, 0); } } } void rotate_r(ESPRotary &r) { //Serial.println(r.getPosition()); } // on left or right rotattion void showDirection_r(ESPRotary &r) { //Serial.println(r.directionToString(r.getDirection())); } // on change void rotate_u(ESPRotary &u) { Serial.println(u.getPosition()); int k = u.getPosition(); bd.setVol_1(k); // int 0...87 === 0...-87 dB Serial.print(\"Vol:\"); Serial.println(k); delay(2); } void showDirection_u(ESPRotary &u) { //Serial.println(u.directionToString(u.getDirection())); } bool encoder_read(lv_indev_drv_t *drv, lv_indev_data_t *data) { data->enc_diff = enc_get_new_moves(); if (mcp1.digitalRead(5) == 1) data->state = LV_INDEV_STATE_PR; else data->state = LV_INDEV_STATE_REL; return false; /*No buffering now so no more data read*/ } int enc_get_new_moves() { int encoderCount = r.getPosition(); int diff = encoderCount - encoderLastValue; encoderLastValue = encoderCount; Serial.print(\"Diff:\"); Serial.println(diff); return diff; } static void slider_event_cb_ingain(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_fade1(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setFad_1(0); (lv_slider_get_value(slider)); } } static void slider_event_fade2(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_bass(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_mid(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_treb(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } }","title":"Testsoftware"},{"location":"Testsoftware/#code","text":"Testsoftware v 1.0 - Github /** * @file DAB_2_V0.1.ino * * @mainpage DAB Radio V2.0 * * @section description \u00dcbersicht * An example sketch demonstrating how to use Doxygen style comments for * generating source code documentation with Doxygen. * * @section circuit Produkt * - 1 * - 2 * * @section libraries Libraries * - 2 * - 1 * * @section notes Notizen * - Comments are Doxygen compatible. * * @section todo TODO * - Don't use Doxygen style formatting inside the body of a function. * * @section author Author * - Created by Egzon Isaku on 16/06/2021. * - Modified by * * Copyright (c) RAU Regionales Ausbildungszentrum AU. All rights reserved. */ // Libraries #include <lvgl.h> // Light and versatile Embedded Graphics Library (LVGL) #include <TFT_eSPI.h> // General TFT library (TFT_eSPI) #include \"touch.h\" // Communication header for the touch controller - between \"FT6206\" and LVGL #include <Wire.h> // Arduino I2C library #include <PCA9634.h> // Led driver library (PCA9634) #include <MCP23017.h> // Port expander library (MPC23017) #include \"BM83.h\" // Bluetooth Module library (BM83/BM64) #include <SoftwareSerial.h> // SoftwareSerial Library for ESP32 #include <BD37544FS.h> // Sound processor library (BD37544FS) #include \"ESPRotary.h\" // Encoder Library f\u00fcr ESP32 #include \"soc/timer_group_struct.h\" // Watchdog timer #include \"soc/timer_group_reg.h\" // Watchdog timer // Defines #define BUFFER_MULTIPLIER 35 #define RX_PIN 4 #define TX_PIN 0 #define TX_IND 5 #define DAC1 26 #define ENC1_ROTARY_PIN_A 34 #define ENC1_ROTARY_PIN_B 35 #define ENC2_ROTARY_PIN_A 39 #define ENC2_ROTARY_PIN_B 36 #define CLICKS_PER_STEP 2 // this number depends on your rotary encoder #define MIN_POS 0 #define MAX_POS 87 #define START_POS 0 #define INCREMENT 1 // this number is the counter increment on each step const int mfbPin = 23; ESPRotary r; ESPRotary u; // Sound processor instance (BD37544FS) BD37544FS bd; // Bluetooth module instance (BM83) SoftwareSerial swSerial(RX_PIN, TX_PIN); BM83 bm83(swSerial, TX_IND); // Led driver instance (PCA9634) PCA9634 ledDriver(0x15, 4); // MPC 1 + 2 instance (MCP23017) MCP23017 mcp1 = MCP23017(0x20); MCP23017 mcp2 = MCP23017(0x24); // LVGL task handles TaskHandle_t Task1; TaskHandle_t Task2; static lv_group_t *g; //An object group static lv_indev_t *encoder_indev; //Encoder 1 input device // Global LVGL object variables lv_obj_t *tabview; lv_obj_t *tab1; lv_obj_t *tab2; lv_obj_t *tab3; lv_obj_t *tab4; lv_obj_t *gauge1; lv_obj_t *led1; lv_obj_t *btn; lv_obj_t *btn1; lv_obj_t *btn2; lv_obj_t *btn3; lv_obj_t *sw1; lv_obj_t *sw2; lv_obj_t *sw3; lv_obj_t *cont; lv_obj_t *cont2; lv_obj_t *cont3; lv_obj_t *bar1; lv_obj_t *lmeter; lv_obj_t *lmeter2; lv_obj_t *label; lv_obj_t *spinbox; lv_obj_t *slider_label; lv_obj_t *slider_label2; lv_obj_t *slider_label3; lv_obj_t *slider_label4; lv_obj_t *slider_label5; // Global variables uint8_t conf; int i; int vol; int encoderLastValue = 0; TFT_eSPI tft = TFT_eSPI(); /* TFT instance */ static lv_disp_buf_t disp_buf; static lv_color_t buf_1[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; static lv_color_t buf_2[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif /* Display flushing */ void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) { uint32_t w = (area->x2 - area->x1 + 1); uint32_t h = (area->y2 - area->y1 + 1); tft.startWrite(); tft.setAddrWindow(area->x1, area->y1, w, h); tft.pushColors(&color_p->full, w * h, true); tft.endWrite(); lv_disp_flush_ready(disp); } // The standard Arduino setup function used for setup and configuration void setup() { // I2C init @ 100 kHz Wire.begin(); Wire.setClock(100000); // Serial debugging @ 115200 baud Serial.begin(115200); // Software serial for BM83/BM64 Uart communication @ 9600 baud swSerial.begin(9600); // Input read task creation xTaskCreatePinnedToCore( read_inputs, /* Task function. */ \"read_inputs\", /* String with name of task. */ 10000, /* Stack size in bytes. */ NULL, /* Parameter passed as input of the task */ 1, /* Priority of the task. */ &Task1, /* Task handle. */ 0); /* Core 0 or 1 (Core 1 is used for the arduino loop function for now)*/ // Encoder read task creation //xTaskCreatePinnedToCore(encoder_loop, \"encoder_loop\", 10000, NULL, 2, &Task2, 0); // Sets the MFB pin (GPIO23) as output (BM83) pinMode(mfbPin, OUTPUT); // Encoder 1+2 init // Led driver init ledDriver.begin(); // all on (inverted) ledDriver.allOff(); // Charger IC setup---------------------------------------------------------------- Wire.beginTransmission(0x6A); Wire.write(0x14); Wire.write(0xB9); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x02); Wire.write(0x30); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x03); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x04); Wire.write(0x40); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x05); Wire.write(0x66); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x06); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x07); Wire.write(0x89); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x09); Wire.write(0x04); Wire.endTransmission(); // -------------------------------------------------------------------- //MCP 1 init mcp1.init(); mcp1.portMode(MCP23017Port::A, 0b11111111); // Set all as inputs (MCP1) delay(5); //MCP 2 init mcp2.init(); mcp2.portMode(MCP23017Port::A, 0); // Set all as outputs (MCP2) delay(5); // Standby sequence mcp2.digitalWrite(1, 0); // 7.5V disable delay(10); mcp2.digitalWrite(0, 0); // +-5V disable delay(10); mcp2.digitalWrite(2, 0); // PVCC disable delay(10); mcp2.digitalWrite(3, 0); // Power Amp shutdown activation delay(10); mcp2.digitalWrite(4, 1); // Power Amp mute activation // Power up sequence delay(20); mcp2.digitalWrite(1, 1); Serial.println(\"7.5V enabled!\"); // 7.5V enable delay(10); mcp2.digitalWrite(0, 1); Serial.println(\"+-5V enabled!\"); // +-5V enable delay(10); dacWrite(DAC1, 255); delay(10); mcp2.digitalWrite(2, 1); Serial.println(\"PVCC enabled!\"); // PVCC enable delay(10); mcp2.digitalWrite(3, 1); Serial.println(\"Power Amp Shutdown deactivated!\"); // Power amp shutdown deactivation delay(10); mcp2.digitalWrite(4, 0); Serial.println(\"Power Amp Mute deactivated!\"); // Power amp mute deactivation delay(10); // LVGL init lv_init(); #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif // TFT init tft.begin(); tft.setRotation(3); // Touch device init if (!touch.begin(150)) { Serial.println(\"Couldn't start FT6206 touchscreen controller\"); while (1) ; } else { Serial.println(\"FT6206 touchscreen controller connected!\"); } lv_disp_buf_init(&disp_buf, buf_1, buf_2, LV_HOR_RES_MAX * 10); // Display init lv_disp_drv_t disp_drv; lv_disp_drv_init(&disp_drv); disp_drv.hor_res = tft.width(); disp_drv.ver_res = tft.height(); disp_drv.flush_cb = my_disp_flush; disp_drv.buffer = &disp_buf; lv_disp_drv_register(&disp_drv); // Display input driver init lv_indev_drv_t indev_drv; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_POINTER; indev_drv.read_cb = my_touchpad_read; lv_indev_drv_register(&indev_drv); lv_indev_drv_t enc_indev; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_ENCODER; indev_drv.read_cb = encoder_read; encoder_indev = lv_indev_drv_register(&indev_drv); static lv_style_t style1; lv_style_init(&style1); lv_style_set_border_color(&style1, LV_STATE_FOCUSED, LV_COLOR_RED); //Create Group for encoder 1 g = lv_group_create(); lv_indev_set_group(encoder_indev, g); static lv_color_t needle_colors[3]; needle_colors[0] = LV_COLOR_BLUE; needle_colors[1] = LV_COLOR_ORANGE; needle_colors[2] = LV_COLOR_PURPLE; tabview = lv_tabview_create(lv_scr_act(), NULL); lv_tabview_set_btns_pos(tabview, LV_TABVIEW_TAB_POS_BOTTOM); //lv_tabview_set_anim_time(tabview, 100); /*Add 4 tabs (the tabs are page (lv_page) and can be scrolled*/ tab1 = lv_tabview_add_tab(tabview, \"Setups\"); tab2 = lv_tabview_add_tab(tabview, \"Values\"); tab3 = lv_tabview_add_tab(tabview, \"Enables\"); tab4 = lv_tabview_add_tab(tabview, \"Parameters\"); lmeter = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter, 100, 100); lv_obj_align(lmeter, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); lmeter2 = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter2, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter2, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter2, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter2, 100, 100); lv_obj_align(lmeter2, NULL, LV_ALIGN_IN_TOP_RIGHT, 0, 0); cont = lv_cont_create(tab3, NULL); lv_obj_set_auto_realign(cont, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont, LV_FIT_TIGHT); lv_cont_set_layout(cont, LV_LAYOUT_GRID); sw1 = lv_switch_create(cont, NULL); lv_obj_align(sw1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(sw1, NULL); lv_label_set_text(label, \"7.5V\"); lv_obj_set_event_cb(sw1, event_sw1); sw2 = lv_switch_create(cont, NULL); lv_obj_align(sw2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(sw2, NULL); lv_label_set_text(label, \"+-5V\"); lv_obj_set_event_cb(sw2, event_sw1); sw3 = lv_switch_create(cont, NULL); lv_obj_align(sw3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(sw3, NULL); lv_label_set_text(label, \"PVCC\"); lv_obj_set_event_cb(sw3, event_sw1); cont2 = lv_cont_create(tab1, NULL); lv_obj_set_auto_realign(cont2, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont2, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont2, LV_FIT_TIGHT); lv_cont_set_layout(cont2, LV_LAYOUT_GRID); btn1 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn1, event_bm83setup); lv_obj_align(btn1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(btn1, NULL); lv_label_set_text(label, \"BM83 Setup\"); lv_obj_add_style(btn1, LV_BTN_PART_MAIN, &style1); btn2 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn2, event_bm83pair); lv_obj_align(btn2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(btn2, NULL); lv_label_set_text(label, \"BM83 Pairing\"); lv_obj_add_style(btn2, LV_BTN_PART_MAIN, &style1); btn3 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn3, event_soundsetup); lv_obj_align(btn3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(btn3, NULL); lv_label_set_text(label, \"Sound Proc. Setup\"); lv_obj_add_style(btn3, LV_BTN_PART_MAIN, &style1); /* Create a slider in the center of the display */ lv_obj_t *slider = lv_slider_create(tab4, NULL); lv_obj_set_width(slider, LV_DPI * 1); lv_obj_align(slider, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 25); lv_obj_set_event_cb(slider, slider_event_cb_ingain); lv_slider_set_range(slider, 5, 20); /* Create a label below the slider */ slider_label = lv_label_create(tab4, NULL); lv_label_set_text(slider_label, \"0\"); lv_obj_set_auto_realign(slider_label, true); lv_obj_align(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 5, 10); /* Create an informative label */ lv_obj_t *info = lv_label_create(tab4, NULL); lv_label_set_text(info, \"Input Gain (0-20dB)\"); lv_obj_align(info, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 5); //______________________________________________________________ lv_obj_t *slider2 = lv_slider_create(tab4, NULL); lv_obj_set_width(slider2, LV_DPI * 1); lv_obj_align(slider2, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 60); lv_obj_set_event_cb(slider2, slider_event_cb_fade1); lv_slider_set_range(slider2, 0, 87); /* Create a label below the slider */ slider_label2 = lv_label_create(tab4, NULL); lv_label_set_text(slider_label2, \"0\"); lv_obj_set_auto_realign(slider_label2, true); lv_obj_align(slider_label2, slider2, LV_ALIGN_OUT_BOTTOM_MID, 5, 20); /* Create an informative label */ lv_obj_t *info2 = lv_label_create(tab4, NULL); lv_label_set_text(info2, \"Fader 1 (0-(-87dB))\"); lv_obj_align(info2, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 25); lv_group_add_obj(g, tabview); lv_group_add_obj(g, sw1); lv_group_add_obj(g, sw2); lv_group_add_obj(g, sw3); lv_group_add_obj(g, btn1); lv_group_add_obj(g, btn2); lv_group_add_obj(g, btn3); lv_group_set_wrap(g, true); lv_group_set_editing(g, true); r.begin(ENC1_ROTARY_PIN_A, ENC1_ROTARY_PIN_B, CLICKS_PER_STEP); r.setChangedHandler(rotate_r); r.setLeftRotationHandler(showDirection_r); r.setRightRotationHandler(showDirection_r); u.begin(ENC2_ROTARY_PIN_A, ENC2_ROTARY_PIN_B, CLICKS_PER_STEP, MIN_POS, MAX_POS, START_POS, INCREMENT); u.setChangedHandler(rotate_u); u.setLeftRotationHandler(showDirection_u); u.setRightRotationHandler(showDirection_u); } void loop() { // Watchdog timer manip TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; TIMERG0.wdt_feed = 1; TIMERG0.wdt_wprotect = 0; conf = mcp1.readRegister(MCP23017Register::GPIO_A); // MCP1 register read for inputs r.loop(); u.loop(); // LVGL task handler lv_task_handler(); delay(3); } void read_inputs(void *parameter) { for (;;) { bm83.run(); for (i = 7; i >= 0; i--) { if (bitRead(conf, i) == 1) { switch (i) { case 7: break; case 6: break; case 5: break; case 4: lv_tabview_set_tab_act(tabview, 3, LV_ANIM_OFF); break; case 3: lv_tabview_set_tab_act(tabview, 2, LV_ANIM_OFF); break; case 2: lv_tabview_set_tab_act(tabview, 1, LV_ANIM_OFF); break; case 1: lv_tabview_set_tab_act(tabview, 0, LV_ANIM_OFF); break; case 0: break; } } } } vTaskDelay(5); } static void event_bm83setup(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { printf(\"Clicked\\n\"); digitalWrite(mfbPin, HIGH); // sets the MFB Pin 23 \"High\" to power on BM83 over BAT_IN delay(500); bm83.run(); bm83.powerOn(); // Sends \"power on\" command over UART to BM83 digitalWrite(mfbPin, LOW); // sets the MFB Pin 23 \"LOW\" (no longer needed after power on process) } } static void event_bm83pair(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bm83.mmiAction(BM83_MMI_STANDBY_ENTERING_PAIRING); } } static void event_soundsetup(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bd.setSelect(1); // int 0...7 === A B C D E F INPUT_SHORT INPUT_MUTE bd.setIn_gain(0); // int 0...7 === 0...20 dB bd.setVol_1(0); // int 0...87 === 0...-87 dB bd.setFad_1(0); // int 0...87 === 0...-87 dB bd.setFad_2(0); // int 0...87 === 0...-87 dB bd.setBass(0); // int -7...0...+7 === -14...+14 dB bd.setMidd(0); // int -7...0...+7 === -14...+14 dB bd.setTreb(0); // int -7...0...+7 === -14...+14 dB } } static void event_sw1(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { printf(\"State: %s\\n\", lv_switch_get_state(obj) ? \"On\" : \"Off\"); if (lv_switch_get_state(sw1) == 1) { mcp2.digitalWrite(1, 1); } else { mcp2.digitalWrite(1, 0); } if (lv_switch_get_state(sw2) == 1) { mcp2.digitalWrite(0, 1); } else { mcp2.digitalWrite(0, 0); } if (lv_switch_get_state(sw3) == 1) { mcp2.digitalWrite(2, 1); } else { mcp2.digitalWrite(2, 0); } } } void rotate_r(ESPRotary &r) { //Serial.println(r.getPosition()); } // on left or right rotattion void showDirection_r(ESPRotary &r) { //Serial.println(r.directionToString(r.getDirection())); } // on change void rotate_u(ESPRotary &u) { Serial.println(u.getPosition()); int k = u.getPosition(); bd.setVol_1(k); // int 0...87 === 0...-87 dB Serial.print(\"Vol:\"); Serial.println(k); delay(2); } void showDirection_u(ESPRotary &u) { //Serial.println(u.directionToString(u.getDirection())); } bool encoder_read(lv_indev_drv_t *drv, lv_indev_data_t *data) { data->enc_diff = enc_get_new_moves(); if (mcp1.digitalRead(5) == 1) data->state = LV_INDEV_STATE_PR; else data->state = LV_INDEV_STATE_REL; return false; /*No buffering now so no more data read*/ } int enc_get_new_moves() { int encoderCount = r.getPosition(); int diff = encoderCount - encoderLastValue; encoderLastValue = encoderCount; Serial.print(\"Diff:\"); Serial.println(diff); return diff; } static void slider_event_cb_ingain(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_fade1(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setFad_1(0); (lv_slider_get_value(slider)); } } static void slider_event_fade2(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_bass(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_mid(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_treb(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } }","title":"Code"},{"location":"index_classes/","text":"Classes Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Classes"},{"location":"index_classes/#classes","text":"Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Classes"},{"location":"index_examples/","text":"Examples Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Examples"},{"location":"index_examples/#examples","text":"Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Examples"},{"location":"index_files/","text":"Files dir C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021 dir /Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1 file /Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/DAB_2_V0.1.ino file /Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Files"},{"location":"index_files/#files","text":"dir C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021 dir /Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1 file /Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/DAB_2_V0.1.ino file /Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Files"},{"location":"index_groups/","text":"Modules Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Modules"},{"location":"index_groups/#modules","text":"Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Modules"},{"location":"index_namespaces/","text":"Namespaces Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Namespaces"},{"location":"index_namespaces/#namespaces","text":"Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Namespaces"},{"location":"index_pages/","text":"Pages Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Pages"},{"location":"index_pages/#pages","text":"Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Pages"},{"location":"Files/_d_a_b__2___v0_81_8ino/","text":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/DAB_2_V0.1.ino Functions Name SoftwareSerial swSerial ( RX_PIN , TX_PIN ) Software serial instance (BM83) BM83 bm83 ( swSerial , TX_IND ) BM83 instance (BM83) PCA9634 ledDriver (0x15 , 4 ) Led driver instance (PCA9634) void my_disp_flush (lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) void setup () void loop () void read_inputs (void * parameter) void event_bm83setup (lv_obj_t * obj, lv_event_t event) void event_bm83pair (lv_obj_t * obj, lv_event_t event) void event_soundsetup (lv_obj_t * obj, lv_event_t event) void event_sw1 (lv_obj_t * obj, lv_event_t event) void rotate_r (ESPRotary & r) void showDirection_r (ESPRotary & r) void rotate_u (ESPRotary & u) void showDirection_u (ESPRotary & u) bool encoder_read (lv_indev_drv_t * drv, lv_indev_data_t * data) int enc_get_new_moves () void slider_event_cb_ingain (lv_obj_t * slider, lv_event_t event) void slider_event_cb_fade1 (lv_obj_t * slider, lv_event_t event) void slider_event_fade2 (lv_obj_t * slider, lv_event_t event) void slider_event_cb_bass (lv_obj_t * slider, lv_event_t event) void slider_event_mid (lv_obj_t * slider, lv_event_t event) void slider_event_treb (lv_obj_t * slider, lv_event_t event) Attributes Name const int mfbPin BM83 MFB Pin, required for BM83 power on. ESPRotary r Encoder 1 instance. ESPRotary u Encoder 2 instance. BD37544FS bd Sound processor instance (BD37544FS) MCP23017 mcp1 MCP1 (Display board) MCP23017 mcp2 MCP2 (MCU board) TaskHandle_t Task1 Task handle. TaskHandle_t Task2 Task handle. lv_group_t * g lv_indev_t * encoder_indev lv_obj_t * tabview lv_obj_t * tab1 lv_obj_t * tab2 lv_obj_t * tab3 lv_obj_t * tab4 lv_obj_t * gauge1 lv_obj_t * led1 lv_obj_t * btn lv_obj_t * btn1 lv_obj_t * btn2 lv_obj_t * btn3 lv_obj_t * sw1 lv_obj_t * sw2 lv_obj_t * sw3 lv_obj_t * cont lv_obj_t * cont2 lv_obj_t * cont3 lv_obj_t * bar1 lv_obj_t * lmeter lv_obj_t * lmeter2 lv_obj_t * label lv_obj_t * spinbox lv_obj_t * slider_label lv_obj_t * slider_label2 lv_obj_t * slider_label3 lv_obj_t * slider_label4 lv_obj_t * slider_label5 uint8_t conf int i int vol int encoderLastValue int k TFT_eSPI tft lv_disp_buf_t disp_buf lv_color_t buf_1 lv_color_t buf_2 Defines Name BUFFER_MULTIPLIER LVGL buffer. RX_PIN BM83 UART RX. TX_PIN BM83 UART TX. TX_IND BM83 TX IND. DAC1 DAC pin for DC_SET_V. ENC1_ROTARY_PIN_A Encoder 1 Pin A. ENC1_ROTARY_PIN_B Encoder 1 Pin B. ENC2_ROTARY_PIN_A Encoder 2 Pin A. ENC2_ROTARY_PIN_B Encoder 2 Pin B. CLICKS_PER_STEP MIN_POS Max volume 0 dB. MAX_POS Min volume -87 dB. START_POS Volume start position. INCREMENT Volume increment. Functions Documentation function swSerial SoftwareSerial swSerial( RX_PIN , TX_PIN ) Software serial instance (BM83) function bm83 BM83 bm83( swSerial , TX_IND ) BM83 instance (BM83) function ledDriver PCA9634 ledDriver( 0x15 , 4 ) Led driver instance (PCA9634) function my_disp_flush void my_disp_flush( lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p ) function setup void setup() function loop void loop() < Watchdog timer manipulation function read_inputs void read_inputs( void * parameter ) function event_bm83setup static void event_bm83setup( lv_obj_t * obj, lv_event_t event ) function event_bm83pair static void event_bm83pair( lv_obj_t * obj, lv_event_t event ) function event_soundsetup static void event_soundsetup( lv_obj_t * obj, lv_event_t event ) function event_sw1 static void event_sw1( lv_obj_t * obj, lv_event_t event ) function rotate_r void rotate_r( ESPRotary & r ) function showDirection_r void showDirection_r( ESPRotary & r ) function rotate_u void rotate_u( ESPRotary & u ) function showDirection_u void showDirection_u( ESPRotary & u ) function encoder_read bool encoder_read( lv_indev_drv_t * drv, lv_indev_data_t * data ) function enc_get_new_moves int enc_get_new_moves() function slider_event_cb_ingain static void slider_event_cb_ingain( lv_obj_t * slider, lv_event_t event ) function slider_event_cb_fade1 static void slider_event_cb_fade1( lv_obj_t * slider, lv_event_t event ) function slider_event_fade2 static void slider_event_fade2( lv_obj_t * slider, lv_event_t event ) function slider_event_cb_bass static void slider_event_cb_bass( lv_obj_t * slider, lv_event_t event ) function slider_event_mid static void slider_event_mid( lv_obj_t * slider, lv_event_t event ) function slider_event_treb static void slider_event_treb( lv_obj_t * slider, lv_event_t event ) Attributes Documentation variable mfbPin const int mfbPin = 23; BM83 MFB Pin, required for BM83 power on. variable r ESPRotary r; Encoder 1 instance. variable u ESPRotary u; Encoder 2 instance. variable bd BD37544FS bd; Sound processor instance (BD37544FS) variable mcp1 MCP23017 mcp1 = MCP23017(0x20); MCP1 (Display board) variable mcp2 MCP23017 mcp2 = MCP23017(0x24); MCP2 (MCU board) variable Task1 TaskHandle_t Task1; Task handle. variable Task2 TaskHandle_t Task2; Task handle. variable g static lv_group_t * g; variable encoder_indev static lv_indev_t * encoder_indev; variable tabview lv_obj_t * tabview; variable tab1 lv_obj_t * tab1; variable tab2 lv_obj_t * tab2; variable tab3 lv_obj_t * tab3; variable tab4 lv_obj_t * tab4; variable gauge1 lv_obj_t * gauge1; variable led1 lv_obj_t * led1; variable btn lv_obj_t * btn; variable btn1 lv_obj_t * btn1; variable btn2 lv_obj_t * btn2; variable btn3 lv_obj_t * btn3; variable sw1 lv_obj_t * sw1; variable sw2 lv_obj_t * sw2; variable sw3 lv_obj_t * sw3; variable cont lv_obj_t * cont; variable cont2 lv_obj_t * cont2; variable cont3 lv_obj_t * cont3; variable bar1 lv_obj_t * bar1; variable lmeter lv_obj_t * lmeter; variable lmeter2 lv_obj_t * lmeter2; variable label lv_obj_t * label; variable spinbox lv_obj_t * spinbox; variable slider_label lv_obj_t * slider_label; variable slider_label2 lv_obj_t * slider_label2; variable slider_label3 lv_obj_t * slider_label3; variable slider_label4 lv_obj_t * slider_label4; variable slider_label5 lv_obj_t * slider_label5; variable conf uint8_t conf; variable i int i; variable vol int vol; variable encoderLastValue int encoderLastValue = 0; variable k int k; variable tft TFT_eSPI tft = TFT_eSPI(); variable disp_buf static lv_disp_buf_t disp_buf; variable buf_1 static lv_color_t buf_1; variable buf_2 static lv_color_t buf_2; Macros Documentation define BUFFER_MULTIPLIER #define BUFFER_MULTIPLIER 35 LVGL buffer. define RX_PIN #define RX_PIN 4 BM83 UART RX. define TX_PIN #define TX_PIN 0 BM83 UART TX. define TX_IND #define TX_IND 5 BM83 TX IND. define DAC1 #define DAC1 26 DAC pin for DC_SET_V. define ENC1_ROTARY_PIN_A #define ENC1_ROTARY_PIN_A 34 Encoder 1 Pin A. define ENC1_ROTARY_PIN_B #define ENC1_ROTARY_PIN_B 35 Encoder 1 Pin B. define ENC2_ROTARY_PIN_A #define ENC2_ROTARY_PIN_A 39 Encoder 2 Pin A. define ENC2_ROTARY_PIN_B #define ENC2_ROTARY_PIN_B 36 Encoder 2 Pin B. define CLICKS_PER_STEP #define CLICKS_PER_STEP 2 define MIN_POS #define MIN_POS 0 Max volume 0 dB. define MAX_POS #define MAX_POS 87 Min volume -87 dB. define START_POS #define START_POS 0 Volume start position. define INCREMENT #define INCREMENT 1 Volume increment. Source code // Libraries #include <lvgl.h> // Light and versatile Embedded Graphics Library (LVGL) #include <TFT_eSPI.h> // General TFT library (TFT_eSPI) #include \"touch.h\" // Communication header for the touch controller - between \"FT6206\" and LVGL #include <Wire.h> // Arduino I2C library #include <PCA9634.h> // Led driver library (PCA9634) #include <MCP23017.h> // Port expander library (MPC23017) #include \"BM83.h\" // Bluetooth Module library (BM83/BM64) #include <SoftwareSerial.h> // SoftwareSerial Library for ESP32 #include <BD37544FS.h> // Sound processor library (BD37544FS) #include \"ESPRotary.h\" // Encoder Library f\u00fcr ESP32 #include \"soc/timer_group_struct.h\" // Watchdog timer #include \"soc/timer_group_reg.h\" // Watchdog timer #define BUFFER_MULTIPLIER 35 #define RX_PIN 4 #define TX_PIN 0 #define TX_IND 5 #define DAC1 26 #define ENC1_ROTARY_PIN_A 34 #define ENC1_ROTARY_PIN_B 35 #define ENC2_ROTARY_PIN_A 39 #define ENC2_ROTARY_PIN_B 36 #define CLICKS_PER_STEP 2 // Number depends on the encoder #define MIN_POS 0 #define MAX_POS 87 #define START_POS 0 #define INCREMENT 1 const int mfbPin = 23; ESPRotary r; ESPRotary u; BD37544FS bd; SoftwareSerial swSerial(RX_PIN, TX_PIN); BM83 bm83(swSerial, TX_IND); PCA9634 ledDriver(0x15, 4); MCP23017 mcp1 = MCP23017(0x20); MCP23017 mcp2 = MCP23017(0x24); TaskHandle_t Task1; TaskHandle_t Task2; static lv_group_t *g; //An object group static lv_indev_t *encoder_indev; //Encoder 1 input device // Global LVGL object variables lv_obj_t *tabview; lv_obj_t *tab1; lv_obj_t *tab2; lv_obj_t *tab3; lv_obj_t *tab4; lv_obj_t *gauge1; lv_obj_t *led1; lv_obj_t *btn; lv_obj_t *btn1; lv_obj_t *btn2; lv_obj_t *btn3; lv_obj_t *sw1; lv_obj_t *sw2; lv_obj_t *sw3; lv_obj_t *cont; lv_obj_t *cont2; lv_obj_t *cont3; lv_obj_t *bar1; lv_obj_t *lmeter; lv_obj_t *lmeter2; lv_obj_t *label; lv_obj_t *spinbox; lv_obj_t *slider_label; lv_obj_t *slider_label2; lv_obj_t *slider_label3; lv_obj_t *slider_label4; lv_obj_t *slider_label5; // Global variables uint8_t conf; int i; int vol; int encoderLastValue = 0; int k; // Current enocder position (volume) TFT_eSPI tft = TFT_eSPI(); /* TFT instance */ static lv_disp_buf_t disp_buf; static lv_color_t buf_1[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; static lv_color_t buf_2[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif /* Display flushing */ void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) { uint32_t w = (area->x2 - area->x1 + 1); uint32_t h = (area->y2 - area->y1 + 1); tft.startWrite(); tft.setAddrWindow(area->x1, area->y1, w, h); tft.pushColors(&color_p->full, w * h, true); tft.endWrite(); lv_disp_flush_ready(disp); } // The standard Arduino setup function used for setup and configuration void setup() { // I2C init @ 100 kHz Wire.begin(); Wire.setClock(100000); // Serial debugging @ 115200 baud Serial.begin(115200); // Software serial for BM83/BM64 Uart communication @ 9600 baud swSerial.begin(9600); // Input read task creation xTaskCreatePinnedToCore( read_inputs, /* Task function. */ \"read_inputs\", /* String with name of task. */ 10000, /* Stack size in bytes. */ NULL, /* Parameter passed as input of the task */ 1, /* Priority of the task. */ &Task1, /* Task handle. */ 0); /* Core 0 or 1 (Core 1 is used for the arduino loop function for now)*/ // Encoder read task creation //xTaskCreatePinnedToCore(encoder_loop, \"encoder_loop\", 10000, NULL, 2, &Task2, 0); // Sets the MFB pin (GPIO23) as output (BM83) pinMode(mfbPin, OUTPUT); // Encoder 1+2 init // Led driver init ledDriver.begin(); // all on (inverted) ledDriver.allOff(); // Charger IC setup---------------------------------------------------------------- Wire.beginTransmission(0x6A); Wire.write(0x14); Wire.write(0xB9); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x02); Wire.write(0x30); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x03); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x04); Wire.write(0x40); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x05); Wire.write(0x66); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x06); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x07); Wire.write(0x89); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x09); Wire.write(0x04); Wire.endTransmission(); // -------------------------------------------------------------------- //MCP 1 init mcp1.init(); mcp1.portMode(MCP23017Port::A, 0b11111111); // Set all as inputs (MCP1) delay(5); //MCP 2 init mcp2.init(); mcp2.portMode(MCP23017Port::A, 0); // Set all as outputs (MCP2) delay(5); // Standby sequence mcp2.digitalWrite(1, 0); // 7.5V disable delay(10); mcp2.digitalWrite(0, 0); // +-5V disable delay(10); mcp2.digitalWrite(2, 0); // PVCC disable delay(10); mcp2.digitalWrite(3, 0); // Power Amp shutdown activation delay(10); mcp2.digitalWrite(4, 1); // Power Amp mute activation // Power up sequence delay(20); mcp2.digitalWrite(1, 1); Serial.println(\"7.5V enabled!\"); // 7.5V enable delay(10); mcp2.digitalWrite(0, 1); Serial.println(\"+-5V enabled!\"); // +-5V enable delay(10); dacWrite(DAC1, 255); delay(10); mcp2.digitalWrite(2, 1); Serial.println(\"PVCC enabled!\"); // PVCC enable delay(10); mcp2.digitalWrite(3, 1); Serial.println(\"Power Amp Shutdown deactivated!\"); // Power amp shutdown deactivation delay(10); mcp2.digitalWrite(4, 0); Serial.println(\"Power Amp Mute deactivated!\"); // Power amp mute deactivation delay(10); // LVGL init lv_init(); #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif // TFT init tft.begin(); tft.setRotation(3); // Touch device init if (!touch.begin(150)) { Serial.println(\"Couldn't start FT6206 touchscreen controller\"); while (1) ; } else { Serial.println(\"FT6206 touchscreen controller connected!\"); } lv_disp_buf_init(&disp_buf, buf_1, buf_2, LV_HOR_RES_MAX * 10); // Display init lv_disp_drv_t disp_drv; lv_disp_drv_init(&disp_drv); disp_drv.hor_res = tft.width(); disp_drv.ver_res = tft.height(); disp_drv.flush_cb = my_disp_flush; disp_drv.buffer = &disp_buf; lv_disp_drv_register(&disp_drv); // Display input driver init lv_indev_drv_t indev_drv; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_POINTER; indev_drv.read_cb = my_touchpad_read; lv_indev_drv_register(&indev_drv); lv_indev_drv_t enc_indev; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_ENCODER; indev_drv.read_cb = encoder_read; encoder_indev = lv_indev_drv_register(&indev_drv); static lv_style_t style1; lv_style_init(&style1); lv_style_set_border_color(&style1, LV_STATE_FOCUSED, LV_COLOR_RED); //Create Group for encoder 1 g = lv_group_create(); lv_indev_set_group(encoder_indev, g); static lv_color_t needle_colors[3]; needle_colors[0] = LV_COLOR_BLUE; needle_colors[1] = LV_COLOR_ORANGE; needle_colors[2] = LV_COLOR_PURPLE; tabview = lv_tabview_create(lv_scr_act(), NULL); lv_tabview_set_btns_pos(tabview, LV_TABVIEW_TAB_POS_BOTTOM); //lv_tabview_set_anim_time(tabview, 100); /*Add 4 tabs (the tabs are page (lv_page) and can be scrolled*/ tab1 = lv_tabview_add_tab(tabview, \"Setups\"); tab2 = lv_tabview_add_tab(tabview, \"Values\"); tab3 = lv_tabview_add_tab(tabview, \"Enables\"); tab4 = lv_tabview_add_tab(tabview, \"Parameters\"); lmeter = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter, 100, 100); lv_obj_align(lmeter, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); lmeter2 = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter2, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter2, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter2, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter2, 100, 100); lv_obj_align(lmeter2, NULL, LV_ALIGN_IN_TOP_RIGHT, 0, 0); cont = lv_cont_create(tab3, NULL); lv_obj_set_auto_realign(cont, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont, LV_FIT_TIGHT); lv_cont_set_layout(cont, LV_LAYOUT_GRID); sw1 = lv_switch_create(cont, NULL); lv_obj_align(sw1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(sw1, NULL); lv_label_set_text(label, \"7.5V\"); lv_obj_set_event_cb(sw1, event_sw1); sw2 = lv_switch_create(cont, NULL); lv_obj_align(sw2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(sw2, NULL); lv_label_set_text(label, \"+-5V\"); lv_obj_set_event_cb(sw2, event_sw1); sw3 = lv_switch_create(cont, NULL); lv_obj_align(sw3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(sw3, NULL); lv_label_set_text(label, \"PVCC\"); lv_obj_set_event_cb(sw3, event_sw1); cont2 = lv_cont_create(tab1, NULL); lv_obj_set_auto_realign(cont2, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont2, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont2, LV_FIT_TIGHT); lv_cont_set_layout(cont2, LV_LAYOUT_GRID); btn1 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn1, event_bm83setup); lv_obj_align(btn1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(btn1, NULL); lv_label_set_text(label, \"BM83 Setup\"); lv_obj_add_style(btn1, LV_BTN_PART_MAIN, &style1); btn2 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn2, event_bm83pair); lv_obj_align(btn2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(btn2, NULL); lv_label_set_text(label, \"BM83 Pairing\"); lv_obj_add_style(btn2, LV_BTN_PART_MAIN, &style1); btn3 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn3, event_soundsetup); lv_obj_align(btn3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(btn3, NULL); lv_label_set_text(label, \"Sound Proc. Setup\"); lv_obj_add_style(btn3, LV_BTN_PART_MAIN, &style1); /* Create a slider in the center of the display */ lv_obj_t *slider = lv_slider_create(tab4, NULL); lv_obj_set_width(slider, LV_DPI * 1); lv_obj_align(slider, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 25); lv_obj_set_event_cb(slider, slider_event_cb_ingain); lv_slider_set_range(slider, 5, 20); /* Create a label below the slider */ slider_label = lv_label_create(tab4, NULL); lv_label_set_text(slider_label, \"0\"); lv_obj_set_auto_realign(slider_label, true); lv_obj_align(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 5, 10); /* Create an informative label */ lv_obj_t *info = lv_label_create(tab4, NULL); lv_label_set_text(info, \"Input Gain (0-20dB)\"); lv_obj_align(info, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 5); //______________________________________________________________ lv_obj_t *slider2 = lv_slider_create(tab4, NULL); lv_obj_set_width(slider2, LV_DPI * 1); lv_obj_align(slider2, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 60); lv_obj_set_event_cb(slider2, slider_event_cb_fade1); lv_slider_set_range(slider2, 0, 87); /* Create a label below the slider */ slider_label2 = lv_label_create(tab4, NULL); lv_label_set_text(slider_label2, \"0\"); lv_obj_set_auto_realign(slider_label2, true); lv_obj_align(slider_label2, slider2, LV_ALIGN_OUT_BOTTOM_MID, 5, 20); /* Create an informative label */ lv_obj_t *info2 = lv_label_create(tab4, NULL); lv_label_set_text(info2, \"Fader 1 (0-(-87dB))\"); lv_obj_align(info2, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 25); lv_group_add_obj(g, tabview); lv_group_add_obj(g, sw1); lv_group_add_obj(g, sw2); lv_group_add_obj(g, sw3); lv_group_add_obj(g, btn1); lv_group_add_obj(g, btn2); lv_group_add_obj(g, btn3); lv_group_set_wrap(g, true); lv_group_set_editing(g, true); r.begin(ENC1_ROTARY_PIN_A, ENC1_ROTARY_PIN_B, CLICKS_PER_STEP); r.setChangedHandler(rotate_r); r.setLeftRotationHandler(showDirection_r); r.setRightRotationHandler(showDirection_r); u.begin(ENC2_ROTARY_PIN_A, ENC2_ROTARY_PIN_B, CLICKS_PER_STEP, MIN_POS, MAX_POS, START_POS, INCREMENT); u.setChangedHandler(rotate_u); u.setLeftRotationHandler(showDirection_u); u.setRightRotationHandler(showDirection_u); } void loop() //< Standard arduino setup function { TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; TIMERG0.wdt_feed = 1; //< TIMERG0.wdt_wprotect = 0; //< conf = mcp1.readRegister(MCP23017Register::GPIO_A); //< MCP1 register read r.loop(); //< Encoder 1 menu loop u.loop(); //< Encoder 2 volume loop lv_task_handler(); //< LVG task handler loop delay(3); } void read_inputs(void *parameter) //< Buttons read function { for (;;) { bm83.run(); for (i = 7; i >= 0; i--) { if (bitRead(conf, i) == 1) { switch (i) { case 7: break; case 6: break; case 5: break; case 4: lv_tabview_set_tab_act(tabview, 3, LV_ANIM_OFF); break; case 3: lv_tabview_set_tab_act(tabview, 2, LV_ANIM_OFF); break; case 2: lv_tabview_set_tab_act(tabview, 1, LV_ANIM_OFF); break; case 1: lv_tabview_set_tab_act(tabview, 0, LV_ANIM_OFF); break; case 0: break; } } } } vTaskDelay(5); } static void event_bm83setup(lv_obj_t *obj, lv_event_t event) //< BM83 setup function { if (event == LV_EVENT_CLICKED) { digitalWrite(mfbPin, HIGH); // sets the MFB Pin 23 \"High\" to power on BM83 over BAT_IN delay(500); bm83.run(); bm83.powerOn(); // Sends \"power on\" command over UART to BM83 digitalWrite(mfbPin, LOW); // sets the MFB Pin 23 \"LOW\" (no longer needed after power on process) } } static void event_bm83pair(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bm83.mmiAction(BM83_MMI_STANDBY_ENTERING_PAIRING); } } static void event_soundsetup(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bd.setSelect(1); // int 0...7 === A B C D E F INPUT_SHORT INPUT_MUTE bd.setIn_gain(0); // int 0...7 === 0...20 dB bd.setVol_1(0); // int 0...87 === 0...-87 dB bd.setFad_1(0); // int 0...87 === 0...-87 dB bd.setFad_2(0); // int 0...87 === 0...-87 dB bd.setBass(0); // int -7...0...+7 === -14...+14 dB bd.setMidd(0); // int -7...0...+7 === -14...+14 dB bd.setTreb(0); // int -7...0...+7 === -14...+14 dB } } static void event_sw1(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { printf(\"State: %s\\n\", lv_switch_get_state(obj) ? \"On\" : \"Off\"); if (lv_switch_get_state(sw1) == 1) { mcp2.digitalWrite(1, 1); } else { mcp2.digitalWrite(1, 0); } if (lv_switch_get_state(sw2) == 1) { mcp2.digitalWrite(0, 1); } else { mcp2.digitalWrite(0, 0); } if (lv_switch_get_state(sw3) == 1) { mcp2.digitalWrite(2, 1); } else { mcp2.digitalWrite(2, 0); } } } // on change void rotate_r(ESPRotary &r) { //Serial.println(r.getPosition()); } // on left or right rotattion void showDirection_r(ESPRotary &r) { //Serial.println(r.directionToString(r.getDirection())); } // on change void rotate_u(ESPRotary &u) { Serial.println(u.getPosition()); k = u.getPosition(); bd.setVol_1(k); // int 0...87 === 0...-87 dB Serial.print(\"Vol:\"); Serial.println(k); delay(2); } void showDirection_u(ESPRotary &u) { //Serial.println(u.directionToString(u.getDirection())); } bool encoder_read(lv_indev_drv_t *drv, lv_indev_data_t *data) { data->enc_diff = enc_get_new_moves(); if (mcp1.digitalRead(5) == 1) data->state = LV_INDEV_STATE_PR; else data->state = LV_INDEV_STATE_REL; return false; /*No buffering now so no more data read*/ } int enc_get_new_moves() { int encoderCount = r.getPosition(); int diff = encoderCount - encoderLastValue; encoderLastValue = encoderCount; Serial.print(\"Diff:\"); Serial.println(diff); return diff; } static void slider_event_cb_ingain(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_fade1(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setFad_1(0); (lv_slider_get_value(slider)); } } static void slider_event_fade2(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_bass(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_mid(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_treb(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Source Code"},{"location":"Files/_d_a_b__2___v0_81_8ino/#cusersjackdocumentsgithubrau-dab-radio-v2new-code_ab-16062021dab_2_v01dab_2_v01ino","text":"","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/DAB_2_V0.1.ino"},{"location":"Files/_d_a_b__2___v0_81_8ino/#functions","text":"Name SoftwareSerial swSerial ( RX_PIN , TX_PIN ) Software serial instance (BM83) BM83 bm83 ( swSerial , TX_IND ) BM83 instance (BM83) PCA9634 ledDriver (0x15 , 4 ) Led driver instance (PCA9634) void my_disp_flush (lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) void setup () void loop () void read_inputs (void * parameter) void event_bm83setup (lv_obj_t * obj, lv_event_t event) void event_bm83pair (lv_obj_t * obj, lv_event_t event) void event_soundsetup (lv_obj_t * obj, lv_event_t event) void event_sw1 (lv_obj_t * obj, lv_event_t event) void rotate_r (ESPRotary & r) void showDirection_r (ESPRotary & r) void rotate_u (ESPRotary & u) void showDirection_u (ESPRotary & u) bool encoder_read (lv_indev_drv_t * drv, lv_indev_data_t * data) int enc_get_new_moves () void slider_event_cb_ingain (lv_obj_t * slider, lv_event_t event) void slider_event_cb_fade1 (lv_obj_t * slider, lv_event_t event) void slider_event_fade2 (lv_obj_t * slider, lv_event_t event) void slider_event_cb_bass (lv_obj_t * slider, lv_event_t event) void slider_event_mid (lv_obj_t * slider, lv_event_t event) void slider_event_treb (lv_obj_t * slider, lv_event_t event)","title":"Functions"},{"location":"Files/_d_a_b__2___v0_81_8ino/#attributes","text":"Name const int mfbPin BM83 MFB Pin, required for BM83 power on. ESPRotary r Encoder 1 instance. ESPRotary u Encoder 2 instance. BD37544FS bd Sound processor instance (BD37544FS) MCP23017 mcp1 MCP1 (Display board) MCP23017 mcp2 MCP2 (MCU board) TaskHandle_t Task1 Task handle. TaskHandle_t Task2 Task handle. lv_group_t * g lv_indev_t * encoder_indev lv_obj_t * tabview lv_obj_t * tab1 lv_obj_t * tab2 lv_obj_t * tab3 lv_obj_t * tab4 lv_obj_t * gauge1 lv_obj_t * led1 lv_obj_t * btn lv_obj_t * btn1 lv_obj_t * btn2 lv_obj_t * btn3 lv_obj_t * sw1 lv_obj_t * sw2 lv_obj_t * sw3 lv_obj_t * cont lv_obj_t * cont2 lv_obj_t * cont3 lv_obj_t * bar1 lv_obj_t * lmeter lv_obj_t * lmeter2 lv_obj_t * label lv_obj_t * spinbox lv_obj_t * slider_label lv_obj_t * slider_label2 lv_obj_t * slider_label3 lv_obj_t * slider_label4 lv_obj_t * slider_label5 uint8_t conf int i int vol int encoderLastValue int k TFT_eSPI tft lv_disp_buf_t disp_buf lv_color_t buf_1 lv_color_t buf_2","title":"Attributes"},{"location":"Files/_d_a_b__2___v0_81_8ino/#defines","text":"Name BUFFER_MULTIPLIER LVGL buffer. RX_PIN BM83 UART RX. TX_PIN BM83 UART TX. TX_IND BM83 TX IND. DAC1 DAC pin for DC_SET_V. ENC1_ROTARY_PIN_A Encoder 1 Pin A. ENC1_ROTARY_PIN_B Encoder 1 Pin B. ENC2_ROTARY_PIN_A Encoder 2 Pin A. ENC2_ROTARY_PIN_B Encoder 2 Pin B. CLICKS_PER_STEP MIN_POS Max volume 0 dB. MAX_POS Min volume -87 dB. START_POS Volume start position. INCREMENT Volume increment.","title":"Defines"},{"location":"Files/_d_a_b__2___v0_81_8ino/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-swserial","text":"SoftwareSerial swSerial( RX_PIN , TX_PIN ) Software serial instance (BM83)","title":"function swSerial"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-bm83","text":"BM83 bm83( swSerial , TX_IND ) BM83 instance (BM83)","title":"function bm83"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-leddriver","text":"PCA9634 ledDriver( 0x15 , 4 ) Led driver instance (PCA9634)","title":"function ledDriver"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-my_disp_flush","text":"void my_disp_flush( lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p )","title":"function my_disp_flush"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-setup","text":"void setup()","title":"function setup"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-loop","text":"void loop() < Watchdog timer manipulation","title":"function loop"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-read_inputs","text":"void read_inputs( void * parameter )","title":"function read_inputs"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-event_bm83setup","text":"static void event_bm83setup( lv_obj_t * obj, lv_event_t event )","title":"function event_bm83setup"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-event_bm83pair","text":"static void event_bm83pair( lv_obj_t * obj, lv_event_t event )","title":"function event_bm83pair"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-event_soundsetup","text":"static void event_soundsetup( lv_obj_t * obj, lv_event_t event )","title":"function event_soundsetup"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-event_sw1","text":"static void event_sw1( lv_obj_t * obj, lv_event_t event )","title":"function event_sw1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-rotate_r","text":"void rotate_r( ESPRotary & r )","title":"function rotate_r"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-showdirection_r","text":"void showDirection_r( ESPRotary & r )","title":"function showDirection_r"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-rotate_u","text":"void rotate_u( ESPRotary & u )","title":"function rotate_u"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-showdirection_u","text":"void showDirection_u( ESPRotary & u )","title":"function showDirection_u"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-encoder_read","text":"bool encoder_read( lv_indev_drv_t * drv, lv_indev_data_t * data )","title":"function encoder_read"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-enc_get_new_moves","text":"int enc_get_new_moves()","title":"function enc_get_new_moves"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-slider_event_cb_ingain","text":"static void slider_event_cb_ingain( lv_obj_t * slider, lv_event_t event )","title":"function slider_event_cb_ingain"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-slider_event_cb_fade1","text":"static void slider_event_cb_fade1( lv_obj_t * slider, lv_event_t event )","title":"function slider_event_cb_fade1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-slider_event_fade2","text":"static void slider_event_fade2( lv_obj_t * slider, lv_event_t event )","title":"function slider_event_fade2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-slider_event_cb_bass","text":"static void slider_event_cb_bass( lv_obj_t * slider, lv_event_t event )","title":"function slider_event_cb_bass"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-slider_event_mid","text":"static void slider_event_mid( lv_obj_t * slider, lv_event_t event )","title":"function slider_event_mid"},{"location":"Files/_d_a_b__2___v0_81_8ino/#function-slider_event_treb","text":"static void slider_event_treb( lv_obj_t * slider, lv_event_t event )","title":"function slider_event_treb"},{"location":"Files/_d_a_b__2___v0_81_8ino/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-mfbpin","text":"const int mfbPin = 23; BM83 MFB Pin, required for BM83 power on.","title":"variable mfbPin"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-r","text":"ESPRotary r; Encoder 1 instance.","title":"variable r"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-u","text":"ESPRotary u; Encoder 2 instance.","title":"variable u"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-bd","text":"BD37544FS bd; Sound processor instance (BD37544FS)","title":"variable bd"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-mcp1","text":"MCP23017 mcp1 = MCP23017(0x20); MCP1 (Display board)","title":"variable mcp1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-mcp2","text":"MCP23017 mcp2 = MCP23017(0x24); MCP2 (MCU board)","title":"variable mcp2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-task1","text":"TaskHandle_t Task1; Task handle.","title":"variable Task1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-task2","text":"TaskHandle_t Task2; Task handle.","title":"variable Task2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-g","text":"static lv_group_t * g;","title":"variable g"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-encoder_indev","text":"static lv_indev_t * encoder_indev;","title":"variable encoder_indev"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-tabview","text":"lv_obj_t * tabview;","title":"variable tabview"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-tab1","text":"lv_obj_t * tab1;","title":"variable tab1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-tab2","text":"lv_obj_t * tab2;","title":"variable tab2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-tab3","text":"lv_obj_t * tab3;","title":"variable tab3"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-tab4","text":"lv_obj_t * tab4;","title":"variable tab4"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-gauge1","text":"lv_obj_t * gauge1;","title":"variable gauge1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-led1","text":"lv_obj_t * led1;","title":"variable led1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-btn","text":"lv_obj_t * btn;","title":"variable btn"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-btn1","text":"lv_obj_t * btn1;","title":"variable btn1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-btn2","text":"lv_obj_t * btn2;","title":"variable btn2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-btn3","text":"lv_obj_t * btn3;","title":"variable btn3"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-sw1","text":"lv_obj_t * sw1;","title":"variable sw1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-sw2","text":"lv_obj_t * sw2;","title":"variable sw2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-sw3","text":"lv_obj_t * sw3;","title":"variable sw3"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-cont","text":"lv_obj_t * cont;","title":"variable cont"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-cont2","text":"lv_obj_t * cont2;","title":"variable cont2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-cont3","text":"lv_obj_t * cont3;","title":"variable cont3"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-bar1","text":"lv_obj_t * bar1;","title":"variable bar1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-lmeter","text":"lv_obj_t * lmeter;","title":"variable lmeter"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-lmeter2","text":"lv_obj_t * lmeter2;","title":"variable lmeter2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-label","text":"lv_obj_t * label;","title":"variable label"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-spinbox","text":"lv_obj_t * spinbox;","title":"variable spinbox"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-slider_label","text":"lv_obj_t * slider_label;","title":"variable slider_label"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-slider_label2","text":"lv_obj_t * slider_label2;","title":"variable slider_label2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-slider_label3","text":"lv_obj_t * slider_label3;","title":"variable slider_label3"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-slider_label4","text":"lv_obj_t * slider_label4;","title":"variable slider_label4"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-slider_label5","text":"lv_obj_t * slider_label5;","title":"variable slider_label5"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-conf","text":"uint8_t conf;","title":"variable conf"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-i","text":"int i;","title":"variable i"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-vol","text":"int vol;","title":"variable vol"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-encoderlastvalue","text":"int encoderLastValue = 0;","title":"variable encoderLastValue"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-k","text":"int k;","title":"variable k"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-tft","text":"TFT_eSPI tft = TFT_eSPI();","title":"variable tft"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-disp_buf","text":"static lv_disp_buf_t disp_buf;","title":"variable disp_buf"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-buf_1","text":"static lv_color_t buf_1;","title":"variable buf_1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#variable-buf_2","text":"static lv_color_t buf_2;","title":"variable buf_2"},{"location":"Files/_d_a_b__2___v0_81_8ino/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-buffer_multiplier","text":"#define BUFFER_MULTIPLIER 35 LVGL buffer.","title":"define BUFFER_MULTIPLIER"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-rx_pin","text":"#define RX_PIN 4 BM83 UART RX.","title":"define RX_PIN"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-tx_pin","text":"#define TX_PIN 0 BM83 UART TX.","title":"define TX_PIN"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-tx_ind","text":"#define TX_IND 5 BM83 TX IND.","title":"define TX_IND"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-dac1","text":"#define DAC1 26 DAC pin for DC_SET_V.","title":"define DAC1"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-enc1_rotary_pin_a","text":"#define ENC1_ROTARY_PIN_A 34 Encoder 1 Pin A.","title":"define ENC1_ROTARY_PIN_A"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-enc1_rotary_pin_b","text":"#define ENC1_ROTARY_PIN_B 35 Encoder 1 Pin B.","title":"define ENC1_ROTARY_PIN_B"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-enc2_rotary_pin_a","text":"#define ENC2_ROTARY_PIN_A 39 Encoder 2 Pin A.","title":"define ENC2_ROTARY_PIN_A"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-enc2_rotary_pin_b","text":"#define ENC2_ROTARY_PIN_B 36 Encoder 2 Pin B.","title":"define ENC2_ROTARY_PIN_B"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-clicks_per_step","text":"#define CLICKS_PER_STEP 2","title":"define CLICKS_PER_STEP"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-min_pos","text":"#define MIN_POS 0 Max volume 0 dB.","title":"define MIN_POS"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-max_pos","text":"#define MAX_POS 87 Min volume -87 dB.","title":"define MAX_POS"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-start_pos","text":"#define START_POS 0 Volume start position.","title":"define START_POS"},{"location":"Files/_d_a_b__2___v0_81_8ino/#define-increment","text":"#define INCREMENT 1 Volume increment.","title":"define INCREMENT"},{"location":"Files/_d_a_b__2___v0_81_8ino/#source-code","text":"// Libraries #include <lvgl.h> // Light and versatile Embedded Graphics Library (LVGL) #include <TFT_eSPI.h> // General TFT library (TFT_eSPI) #include \"touch.h\" // Communication header for the touch controller - between \"FT6206\" and LVGL #include <Wire.h> // Arduino I2C library #include <PCA9634.h> // Led driver library (PCA9634) #include <MCP23017.h> // Port expander library (MPC23017) #include \"BM83.h\" // Bluetooth Module library (BM83/BM64) #include <SoftwareSerial.h> // SoftwareSerial Library for ESP32 #include <BD37544FS.h> // Sound processor library (BD37544FS) #include \"ESPRotary.h\" // Encoder Library f\u00fcr ESP32 #include \"soc/timer_group_struct.h\" // Watchdog timer #include \"soc/timer_group_reg.h\" // Watchdog timer #define BUFFER_MULTIPLIER 35 #define RX_PIN 4 #define TX_PIN 0 #define TX_IND 5 #define DAC1 26 #define ENC1_ROTARY_PIN_A 34 #define ENC1_ROTARY_PIN_B 35 #define ENC2_ROTARY_PIN_A 39 #define ENC2_ROTARY_PIN_B 36 #define CLICKS_PER_STEP 2 // Number depends on the encoder #define MIN_POS 0 #define MAX_POS 87 #define START_POS 0 #define INCREMENT 1 const int mfbPin = 23; ESPRotary r; ESPRotary u; BD37544FS bd; SoftwareSerial swSerial(RX_PIN, TX_PIN); BM83 bm83(swSerial, TX_IND); PCA9634 ledDriver(0x15, 4); MCP23017 mcp1 = MCP23017(0x20); MCP23017 mcp2 = MCP23017(0x24); TaskHandle_t Task1; TaskHandle_t Task2; static lv_group_t *g; //An object group static lv_indev_t *encoder_indev; //Encoder 1 input device // Global LVGL object variables lv_obj_t *tabview; lv_obj_t *tab1; lv_obj_t *tab2; lv_obj_t *tab3; lv_obj_t *tab4; lv_obj_t *gauge1; lv_obj_t *led1; lv_obj_t *btn; lv_obj_t *btn1; lv_obj_t *btn2; lv_obj_t *btn3; lv_obj_t *sw1; lv_obj_t *sw2; lv_obj_t *sw3; lv_obj_t *cont; lv_obj_t *cont2; lv_obj_t *cont3; lv_obj_t *bar1; lv_obj_t *lmeter; lv_obj_t *lmeter2; lv_obj_t *label; lv_obj_t *spinbox; lv_obj_t *slider_label; lv_obj_t *slider_label2; lv_obj_t *slider_label3; lv_obj_t *slider_label4; lv_obj_t *slider_label5; // Global variables uint8_t conf; int i; int vol; int encoderLastValue = 0; int k; // Current enocder position (volume) TFT_eSPI tft = TFT_eSPI(); /* TFT instance */ static lv_disp_buf_t disp_buf; static lv_color_t buf_1[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; static lv_color_t buf_2[LV_HOR_RES_MAX * BUFFER_MULTIPLIER]; #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif /* Display flushing */ void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) { uint32_t w = (area->x2 - area->x1 + 1); uint32_t h = (area->y2 - area->y1 + 1); tft.startWrite(); tft.setAddrWindow(area->x1, area->y1, w, h); tft.pushColors(&color_p->full, w * h, true); tft.endWrite(); lv_disp_flush_ready(disp); } // The standard Arduino setup function used for setup and configuration void setup() { // I2C init @ 100 kHz Wire.begin(); Wire.setClock(100000); // Serial debugging @ 115200 baud Serial.begin(115200); // Software serial for BM83/BM64 Uart communication @ 9600 baud swSerial.begin(9600); // Input read task creation xTaskCreatePinnedToCore( read_inputs, /* Task function. */ \"read_inputs\", /* String with name of task. */ 10000, /* Stack size in bytes. */ NULL, /* Parameter passed as input of the task */ 1, /* Priority of the task. */ &Task1, /* Task handle. */ 0); /* Core 0 or 1 (Core 1 is used for the arduino loop function for now)*/ // Encoder read task creation //xTaskCreatePinnedToCore(encoder_loop, \"encoder_loop\", 10000, NULL, 2, &Task2, 0); // Sets the MFB pin (GPIO23) as output (BM83) pinMode(mfbPin, OUTPUT); // Encoder 1+2 init // Led driver init ledDriver.begin(); // all on (inverted) ledDriver.allOff(); // Charger IC setup---------------------------------------------------------------- Wire.beginTransmission(0x6A); Wire.write(0x14); Wire.write(0xB9); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x02); Wire.write(0x30); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x03); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x04); Wire.write(0x40); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x05); Wire.write(0x66); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x06); Wire.write(0x5A); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x07); Wire.write(0x89); Wire.endTransmission(); Wire.beginTransmission(0x6A); Wire.write(0x09); Wire.write(0x04); Wire.endTransmission(); // -------------------------------------------------------------------- //MCP 1 init mcp1.init(); mcp1.portMode(MCP23017Port::A, 0b11111111); // Set all as inputs (MCP1) delay(5); //MCP 2 init mcp2.init(); mcp2.portMode(MCP23017Port::A, 0); // Set all as outputs (MCP2) delay(5); // Standby sequence mcp2.digitalWrite(1, 0); // 7.5V disable delay(10); mcp2.digitalWrite(0, 0); // +-5V disable delay(10); mcp2.digitalWrite(2, 0); // PVCC disable delay(10); mcp2.digitalWrite(3, 0); // Power Amp shutdown activation delay(10); mcp2.digitalWrite(4, 1); // Power Amp mute activation // Power up sequence delay(20); mcp2.digitalWrite(1, 1); Serial.println(\"7.5V enabled!\"); // 7.5V enable delay(10); mcp2.digitalWrite(0, 1); Serial.println(\"+-5V enabled!\"); // +-5V enable delay(10); dacWrite(DAC1, 255); delay(10); mcp2.digitalWrite(2, 1); Serial.println(\"PVCC enabled!\"); // PVCC enable delay(10); mcp2.digitalWrite(3, 1); Serial.println(\"Power Amp Shutdown deactivated!\"); // Power amp shutdown deactivation delay(10); mcp2.digitalWrite(4, 0); Serial.println(\"Power Amp Mute deactivated!\"); // Power amp mute deactivation delay(10); // LVGL init lv_init(); #if USE_LV_LOG != 0 /* Serial debugging */ void my_print(lv_log_level_t level, const char *file, uint32_t line, const char *dsc) { Serial.printf(\"%s@%d->%s\\r\\n\", file, line, dsc); Serial.flush(); } #endif // TFT init tft.begin(); tft.setRotation(3); // Touch device init if (!touch.begin(150)) { Serial.println(\"Couldn't start FT6206 touchscreen controller\"); while (1) ; } else { Serial.println(\"FT6206 touchscreen controller connected!\"); } lv_disp_buf_init(&disp_buf, buf_1, buf_2, LV_HOR_RES_MAX * 10); // Display init lv_disp_drv_t disp_drv; lv_disp_drv_init(&disp_drv); disp_drv.hor_res = tft.width(); disp_drv.ver_res = tft.height(); disp_drv.flush_cb = my_disp_flush; disp_drv.buffer = &disp_buf; lv_disp_drv_register(&disp_drv); // Display input driver init lv_indev_drv_t indev_drv; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_POINTER; indev_drv.read_cb = my_touchpad_read; lv_indev_drv_register(&indev_drv); lv_indev_drv_t enc_indev; lv_indev_drv_init(&indev_drv); indev_drv.type = LV_INDEV_TYPE_ENCODER; indev_drv.read_cb = encoder_read; encoder_indev = lv_indev_drv_register(&indev_drv); static lv_style_t style1; lv_style_init(&style1); lv_style_set_border_color(&style1, LV_STATE_FOCUSED, LV_COLOR_RED); //Create Group for encoder 1 g = lv_group_create(); lv_indev_set_group(encoder_indev, g); static lv_color_t needle_colors[3]; needle_colors[0] = LV_COLOR_BLUE; needle_colors[1] = LV_COLOR_ORANGE; needle_colors[2] = LV_COLOR_PURPLE; tabview = lv_tabview_create(lv_scr_act(), NULL); lv_tabview_set_btns_pos(tabview, LV_TABVIEW_TAB_POS_BOTTOM); //lv_tabview_set_anim_time(tabview, 100); /*Add 4 tabs (the tabs are page (lv_page) and can be scrolled*/ tab1 = lv_tabview_add_tab(tabview, \"Setups\"); tab2 = lv_tabview_add_tab(tabview, \"Values\"); tab3 = lv_tabview_add_tab(tabview, \"Enables\"); tab4 = lv_tabview_add_tab(tabview, \"Parameters\"); lmeter = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter, 100, 100); lv_obj_align(lmeter, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); lmeter2 = lv_linemeter_create(tab2, NULL); lv_linemeter_set_range(lmeter2, 0, 20); /*Set the range*/ lv_linemeter_set_value(lmeter2, 0); /*Set the current value*/ lv_linemeter_set_scale(lmeter2, 360, 20); /*Set the angle and number of lines*/ lv_obj_set_size(lmeter2, 100, 100); lv_obj_align(lmeter2, NULL, LV_ALIGN_IN_TOP_RIGHT, 0, 0); cont = lv_cont_create(tab3, NULL); lv_obj_set_auto_realign(cont, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont, LV_FIT_TIGHT); lv_cont_set_layout(cont, LV_LAYOUT_GRID); sw1 = lv_switch_create(cont, NULL); lv_obj_align(sw1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(sw1, NULL); lv_label_set_text(label, \"7.5V\"); lv_obj_set_event_cb(sw1, event_sw1); sw2 = lv_switch_create(cont, NULL); lv_obj_align(sw2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(sw2, NULL); lv_label_set_text(label, \"+-5V\"); lv_obj_set_event_cb(sw2, event_sw1); sw3 = lv_switch_create(cont, NULL); lv_obj_align(sw3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(sw3, NULL); lv_label_set_text(label, \"PVCC\"); lv_obj_set_event_cb(sw3, event_sw1); cont2 = lv_cont_create(tab1, NULL); lv_obj_set_auto_realign(cont2, true); /*Auto realign when the size changes*/ lv_obj_align_origo(cont2, NULL, LV_ALIGN_CENTER, 0, 0); /*This parametrs will be sued when realigned*/ lv_cont_set_fit(cont2, LV_FIT_TIGHT); lv_cont_set_layout(cont2, LV_LAYOUT_GRID); btn1 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn1, event_bm83setup); lv_obj_align(btn1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0); label = lv_label_create(btn1, NULL); lv_label_set_text(label, \"BM83 Setup\"); lv_obj_add_style(btn1, LV_BTN_PART_MAIN, &style1); btn2 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn2, event_bm83pair); lv_obj_align(btn2, NULL, LV_ALIGN_IN_TOP_LEFT, 40, 0); label = lv_label_create(btn2, NULL); lv_label_set_text(label, \"BM83 Pairing\"); lv_obj_add_style(btn2, LV_BTN_PART_MAIN, &style1); btn3 = lv_btn_create(cont2, NULL); lv_obj_set_event_cb(btn3, event_soundsetup); lv_obj_align(btn3, NULL, LV_ALIGN_IN_TOP_LEFT, 80, 0); label = lv_label_create(btn3, NULL); lv_label_set_text(label, \"Sound Proc. Setup\"); lv_obj_add_style(btn3, LV_BTN_PART_MAIN, &style1); /* Create a slider in the center of the display */ lv_obj_t *slider = lv_slider_create(tab4, NULL); lv_obj_set_width(slider, LV_DPI * 1); lv_obj_align(slider, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 25); lv_obj_set_event_cb(slider, slider_event_cb_ingain); lv_slider_set_range(slider, 5, 20); /* Create a label below the slider */ slider_label = lv_label_create(tab4, NULL); lv_label_set_text(slider_label, \"0\"); lv_obj_set_auto_realign(slider_label, true); lv_obj_align(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 5, 10); /* Create an informative label */ lv_obj_t *info = lv_label_create(tab4, NULL); lv_label_set_text(info, \"Input Gain (0-20dB)\"); lv_obj_align(info, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 5); //______________________________________________________________ lv_obj_t *slider2 = lv_slider_create(tab4, NULL); lv_obj_set_width(slider2, LV_DPI * 1); lv_obj_align(slider2, NULL, LV_ALIGN_IN_TOP_LEFT, 5, 60); lv_obj_set_event_cb(slider2, slider_event_cb_fade1); lv_slider_set_range(slider2, 0, 87); /* Create a label below the slider */ slider_label2 = lv_label_create(tab4, NULL); lv_label_set_text(slider_label2, \"0\"); lv_obj_set_auto_realign(slider_label2, true); lv_obj_align(slider_label2, slider2, LV_ALIGN_OUT_BOTTOM_MID, 5, 20); /* Create an informative label */ lv_obj_t *info2 = lv_label_create(tab4, NULL); lv_label_set_text(info2, \"Fader 1 (0-(-87dB))\"); lv_obj_align(info2, NULL, LV_ALIGN_IN_TOP_LEFT, 10, 25); lv_group_add_obj(g, tabview); lv_group_add_obj(g, sw1); lv_group_add_obj(g, sw2); lv_group_add_obj(g, sw3); lv_group_add_obj(g, btn1); lv_group_add_obj(g, btn2); lv_group_add_obj(g, btn3); lv_group_set_wrap(g, true); lv_group_set_editing(g, true); r.begin(ENC1_ROTARY_PIN_A, ENC1_ROTARY_PIN_B, CLICKS_PER_STEP); r.setChangedHandler(rotate_r); r.setLeftRotationHandler(showDirection_r); r.setRightRotationHandler(showDirection_r); u.begin(ENC2_ROTARY_PIN_A, ENC2_ROTARY_PIN_B, CLICKS_PER_STEP, MIN_POS, MAX_POS, START_POS, INCREMENT); u.setChangedHandler(rotate_u); u.setLeftRotationHandler(showDirection_u); u.setRightRotationHandler(showDirection_u); } void loop() //< Standard arduino setup function { TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; TIMERG0.wdt_feed = 1; //< TIMERG0.wdt_wprotect = 0; //< conf = mcp1.readRegister(MCP23017Register::GPIO_A); //< MCP1 register read r.loop(); //< Encoder 1 menu loop u.loop(); //< Encoder 2 volume loop lv_task_handler(); //< LVG task handler loop delay(3); } void read_inputs(void *parameter) //< Buttons read function { for (;;) { bm83.run(); for (i = 7; i >= 0; i--) { if (bitRead(conf, i) == 1) { switch (i) { case 7: break; case 6: break; case 5: break; case 4: lv_tabview_set_tab_act(tabview, 3, LV_ANIM_OFF); break; case 3: lv_tabview_set_tab_act(tabview, 2, LV_ANIM_OFF); break; case 2: lv_tabview_set_tab_act(tabview, 1, LV_ANIM_OFF); break; case 1: lv_tabview_set_tab_act(tabview, 0, LV_ANIM_OFF); break; case 0: break; } } } } vTaskDelay(5); } static void event_bm83setup(lv_obj_t *obj, lv_event_t event) //< BM83 setup function { if (event == LV_EVENT_CLICKED) { digitalWrite(mfbPin, HIGH); // sets the MFB Pin 23 \"High\" to power on BM83 over BAT_IN delay(500); bm83.run(); bm83.powerOn(); // Sends \"power on\" command over UART to BM83 digitalWrite(mfbPin, LOW); // sets the MFB Pin 23 \"LOW\" (no longer needed after power on process) } } static void event_bm83pair(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bm83.mmiAction(BM83_MMI_STANDBY_ENTERING_PAIRING); } } static void event_soundsetup(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_CLICKED) { bd.setSelect(1); // int 0...7 === A B C D E F INPUT_SHORT INPUT_MUTE bd.setIn_gain(0); // int 0...7 === 0...20 dB bd.setVol_1(0); // int 0...87 === 0...-87 dB bd.setFad_1(0); // int 0...87 === 0...-87 dB bd.setFad_2(0); // int 0...87 === 0...-87 dB bd.setBass(0); // int -7...0...+7 === -14...+14 dB bd.setMidd(0); // int -7...0...+7 === -14...+14 dB bd.setTreb(0); // int -7...0...+7 === -14...+14 dB } } static void event_sw1(lv_obj_t *obj, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { printf(\"State: %s\\n\", lv_switch_get_state(obj) ? \"On\" : \"Off\"); if (lv_switch_get_state(sw1) == 1) { mcp2.digitalWrite(1, 1); } else { mcp2.digitalWrite(1, 0); } if (lv_switch_get_state(sw2) == 1) { mcp2.digitalWrite(0, 1); } else { mcp2.digitalWrite(0, 0); } if (lv_switch_get_state(sw3) == 1) { mcp2.digitalWrite(2, 1); } else { mcp2.digitalWrite(2, 0); } } } // on change void rotate_r(ESPRotary &r) { //Serial.println(r.getPosition()); } // on left or right rotattion void showDirection_r(ESPRotary &r) { //Serial.println(r.directionToString(r.getDirection())); } // on change void rotate_u(ESPRotary &u) { Serial.println(u.getPosition()); k = u.getPosition(); bd.setVol_1(k); // int 0...87 === 0...-87 dB Serial.print(\"Vol:\"); Serial.println(k); delay(2); } void showDirection_u(ESPRotary &u) { //Serial.println(u.directionToString(u.getDirection())); } bool encoder_read(lv_indev_drv_t *drv, lv_indev_data_t *data) { data->enc_diff = enc_get_new_moves(); if (mcp1.digitalRead(5) == 1) data->state = LV_INDEV_STATE_PR; else data->state = LV_INDEV_STATE_REL; return false; /*No buffering now so no more data read*/ } int enc_get_new_moves() { int encoderCount = r.getPosition(); int diff = encoderCount - encoderLastValue; encoderLastValue = encoderCount; Serial.print(\"Diff:\"); Serial.println(diff); return diff; } static void slider_event_cb_ingain(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_fade1(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setFad_1(0); (lv_slider_get_value(slider)); } } static void slider_event_fade2(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_cb_bass(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_mid(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } static void slider_event_treb(lv_obj_t *slider, lv_event_t event) { if (event == LV_EVENT_VALUE_CHANGED) { static char buf[4]; /* max 3 bytes for number plus 1 null terminating byte */ snprintf(buf, 4, \"%u\", lv_slider_get_value(slider)); lv_label_set_text(slider_label, buf); bd.setIn_gain(lv_slider_get_value(slider)); } } Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Source code"},{"location":"Files/dir_11525a7cfd3aba6af96f56e04121ded6/","text":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021 Directories Name C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1 Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021"},{"location":"Files/dir_11525a7cfd3aba6af96f56e04121ded6/#cusersjackdocumentsgithubrau-dab-radio-v2new-code_ab-16062021","text":"","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021"},{"location":"Files/dir_11525a7cfd3aba6af96f56e04121ded6/#directories","text":"Name C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1 Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Directories"},{"location":"Files/dir_1f5357a0bae416d582bf389114232e5f/","text":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1 Files Name C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/DAB_2_V0.1.ino C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1"},{"location":"Files/dir_1f5357a0bae416d582bf389114232e5f/#cusersjackdocumentsgithubrau-dab-radio-v2new-code_ab-16062021dab_2_v01","text":"","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1"},{"location":"Files/dir_1f5357a0bae416d582bf389114232e5f/#files","text":"Name C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/DAB_2_V0.1.ino C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Files"},{"location":"Files/touch_8h/","text":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h Functions Name bool my_touchpad_read (lv_indev_drv_t * indev_driver, lv_indev_data_t * data) Attributes Name int oldTouchX int oldTouchY Adafruit_FT6206 touch unsigned long last_user_input bool tft_is_off bool tft_needs_on Functions Documentation function my_touchpad_read bool my_touchpad_read( lv_indev_drv_t * indev_driver, lv_indev_data_t * data ) Attributes Documentation variable oldTouchX int oldTouchX = 0; variable oldTouchY int oldTouchY = 0; variable touch static Adafruit_FT6206 touch = Adafruit_FT6206(); variable last_user_input unsigned long last_user_input = 0; variable tft_is_off bool tft_is_off = false; variable tft_needs_on bool tft_needs_on = false; Source code #include <Adafruit_FT6206.h> #include <lvgl.h> int oldTouchX = 0; int oldTouchY = 0; static Adafruit_FT6206 touch = Adafruit_FT6206(); unsigned long last_user_input = 0; bool tft_is_off = false; bool tft_needs_on = false; bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) { uint16_t touchX, touchY; if (touch.touched()) { // First wake up the screen if its shut off if (tft_is_off) { tft_is_off = false; tft_needs_on = true; } // Retrieve a point TS_Point p = touch.getPoint(); touchX = p.y; touchY = p.x; touchY = 240-touchY; //320 instead of 240 for rotation 0 ??? // 2.8\" with Rotation 1 //touchX = p.y; //touchY = p.x; //touchX = 320-touchX; // 3.2\" with Rotation 1 // touchX = p.y; // touchY = p.x; // touchY = 240-touchY; // rotate coordinate system // flip it around to match the screen. only on rotation 0!!!! //uint16_t swapped_touchX = touchY; //touchY = touchX; //touchX = swapped_touchX; //touchX = map(touchX, 0, 320, 320, 0); // touchY = map(touchY, 0, 320, 320, 0); // if ((touchX != oldTouchX) || (touchY != oldTouchY)) //no need // { //no need oldTouchY = touchY; oldTouchX = touchX; data->state = LV_INDEV_STATE_PR; // data->state = touched ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL; data->point.x = touchX; data->point.y = touchY; last_user_input = millis(); Serial.print(\"X: \"); Serial.print(touchX); Serial.print(\" Y: \"); Serial.println(touchY); // } } else { data->point.x = oldTouchX; data->point.y = oldTouchY; data->state =LV_INDEV_STATE_REL; } return 0; } Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h"},{"location":"Files/touch_8h/#cusersjackdocumentsgithubrau-dab-radio-v2new-code_ab-16062021dab_2_v01touchh","text":"","title":"C:/Users/Jack/Documents/GitHub/RAU-DAB-Radio-V2/New Code_ab 16.06.2021/DAB_2_V0.1/touch.h"},{"location":"Files/touch_8h/#functions","text":"Name bool my_touchpad_read (lv_indev_drv_t * indev_driver, lv_indev_data_t * data)","title":"Functions"},{"location":"Files/touch_8h/#attributes","text":"Name int oldTouchX int oldTouchY Adafruit_FT6206 touch unsigned long last_user_input bool tft_is_off bool tft_needs_on","title":"Attributes"},{"location":"Files/touch_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/touch_8h/#function-my_touchpad_read","text":"bool my_touchpad_read( lv_indev_drv_t * indev_driver, lv_indev_data_t * data )","title":"function my_touchpad_read"},{"location":"Files/touch_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Files/touch_8h/#variable-oldtouchx","text":"int oldTouchX = 0;","title":"variable oldTouchX"},{"location":"Files/touch_8h/#variable-oldtouchy","text":"int oldTouchY = 0;","title":"variable oldTouchY"},{"location":"Files/touch_8h/#variable-touch","text":"static Adafruit_FT6206 touch = Adafruit_FT6206();","title":"variable touch"},{"location":"Files/touch_8h/#variable-last_user_input","text":"unsigned long last_user_input = 0;","title":"variable last_user_input"},{"location":"Files/touch_8h/#variable-tft_is_off","text":"bool tft_is_off = false;","title":"variable tft_is_off"},{"location":"Files/touch_8h/#variable-tft_needs_on","text":"bool tft_needs_on = false;","title":"variable tft_needs_on"},{"location":"Files/touch_8h/#source-code","text":"#include <Adafruit_FT6206.h> #include <lvgl.h> int oldTouchX = 0; int oldTouchY = 0; static Adafruit_FT6206 touch = Adafruit_FT6206(); unsigned long last_user_input = 0; bool tft_is_off = false; bool tft_needs_on = false; bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) { uint16_t touchX, touchY; if (touch.touched()) { // First wake up the screen if its shut off if (tft_is_off) { tft_is_off = false; tft_needs_on = true; } // Retrieve a point TS_Point p = touch.getPoint(); touchX = p.y; touchY = p.x; touchY = 240-touchY; //320 instead of 240 for rotation 0 ??? // 2.8\" with Rotation 1 //touchX = p.y; //touchY = p.x; //touchX = 320-touchX; // 3.2\" with Rotation 1 // touchX = p.y; // touchY = p.x; // touchY = 240-touchY; // rotate coordinate system // flip it around to match the screen. only on rotation 0!!!! //uint16_t swapped_touchX = touchY; //touchY = touchX; //touchX = swapped_touchX; //touchX = map(touchX, 0, 320, 320, 0); // touchY = map(touchY, 0, 320, 320, 0); // if ((touchX != oldTouchX) || (touchY != oldTouchY)) //no need // { //no need oldTouchY = touchY; oldTouchX = touchX; data->state = LV_INDEV_STATE_PR; // data->state = touched ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL; data->point.x = touchX; data->point.y = touchY; last_user_input = millis(); Serial.print(\"X: \"); Serial.print(touchX); Serial.print(\" Y: \"); Serial.println(touchY); // } } else { data->point.x = oldTouchX; data->point.y = oldTouchY; data->state =LV_INDEV_STATE_REL; } return 0; } Updated on 1 July 2021 at 16:33:25 W. Europe Summer Time","title":"Source code"}]}